<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/neighborhood.js | neighborhood-wrtc</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="neighborhood (or partial view) containing peers to communicate with"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="neighborhood-wrtc"><meta property="twitter:description" content="neighborhood (or partial view) containing peers to communicate with"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ran3d/neighborhood-wrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/arcstore.js~ArcStore.html">ArcStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/neighborhood.js~Neighborhood.html">Neighborhood</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#entries">entries</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/edying.js~EDying.html">EDying</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/eliving.js~ELiving.html">ELiving</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/epending.js~EPending.html">EPending</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#exceptions">exceptions</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exincompletemessage.js~ExIncompleteMessage.html">ExIncompleteMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exlatemessage.js~ExLateMessage.html">ExLateMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exprotocolexists.js~ExProtocolExists.html">ExProtocolExists</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exsocketnotfound.js~ExSocketNotFound.html">ExSocketNotFound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exundefinedfunction.js~ExUndefinedFunction.html">ExUndefinedFunction</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#interfaces">interfaces</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/interfaces/ineighborhood.js~INeighborhood.html">INeighborhood</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/interfaces/iprotocol.js~IProtocol.html">IProtocol</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#messages">messages</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mrequest.js~MRequest.html">MRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mresponse.js~MResponse.html">MResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/msend.js~MSend.html">MSend</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/neighborhood.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

const debug = (require(&apos;debug&apos;))(&apos;neighborhood-wrtc&apos;)

const merge = require(&apos;lodash.merge&apos;)
const uuid = require(&apos;uuid/v4&apos;)
const Socket = require(&apos;simple-peer&apos;)

const ArcStore = require(&apos;./arcstore.js&apos;)
const EPending = require(&apos;./entries/epending.js&apos;)
const EDying = require(&apos;./entries/edying.js&apos;)

const INeighborhood = require(&apos;./interfaces/ineighborhood.js&apos;)

const MResponse = require(&apos;./messages/mresponse.js&apos;)
const MRequest = require(&apos;./messages/mrequest.js&apos;)
const MSend = require(&apos;./messages/msend.js&apos;)

// const ExLateMessage = require(&apos;./exceptions/exlatemessage.js&apos;)
const ExProtocolExists = require(&apos;./exceptions/exprotocolexists.js&apos;)
const ExIncompleteMessage = require(&apos;./exceptions/exincompletemessage.js&apos;)

/**
 * Easy-to-use interface to establish multiple WebRTC connections using
 * SimplePeer (npm: simple-peer)
 */
class Neighborhood {
  /**
     * @param {object} [options] the options available to the connections, e.g.
     * timeout before
     * @param {object} [options.socketClass] simple-peer default socket class (usefull if you need to change the type of socket)
     * @param {object} [options.config] simple-peer options
     * @param {number} [options.timeout = 60000] Time to wait (in milliseconds) for dying socket
     * @param {number} [options.pendingTimeout = 10000] Time to wait (in milliseconds) for pending socket
     * before neighborhood-wrtc assumes that a connection establishment failed,
     * or before an unused connection is removed.
     * @param {function} [options.encoding] Method to customize message sent,
     * default: return JSON.stringify(data);
     * @param {function} [options.decoding] Method to decode a received message,
     * default: return JSON.parse(data);
     */
  constructor (options) {
    // #1 save options
    this.options = {
      socketClass: Socket,
      peer: uuid(),
      config: { iceServers: [], trickle: true, initiator: false },
      timeout: 1 * 60 * 1000,
      pendingTimeout: 10 * 1000,
      encoding: (d) =&gt; { return JSON.stringify(d) },
      decoding: (d) =&gt; { return JSON.parse(d) }
    }
    this.options = merge(this.options, options)
    this.encode = this.options.encoding // not sure it should stay that
    this.decode = this.options.decoding // way

    // #2 unmutable values
    this.PEER = this.options.peer
    debug(&apos;[%s] initialized.&apos;, this.PEER)

    // #3 initialize tables
    this.pending = new Map() // not finalized yet
    this.living = new ArcStore() // live and usable
    this.dying = new Map() // being removed

    // #4 table of all registered protocols
    this.protocols = new Map()
  }

  /**
     * The protocolId asks this module to get an interface. The interface
     * comprises functions such as connect, disconnect, or send. ProtocolId
     * should provide some functions as well such as failed, opened, received,
     * pid.
     * @param {IProtocol} protocol The protocol that requires the interface.
     * @returns {INeighborhood} The interface to use this module easily.
     */
  register (protocol) {
    if (!this.protocols.has(protocol._pid())) {
      debug(&apos;[%s] protocol %s just registered.&apos;,
        this.PEER, protocol._pid())
      this.protocols.set(protocol._pid(), protocol)
      return new INeighborhood(
        this.PEER,
        this._connect.bind(this, protocol._pid()),
        this._disconnect.bind(this, protocol._pid()),
        this._send.bind(this, protocol._pid())
      )
    } else {
      throw new ExProtocolExists(protocol._pid())
    }
  }

  // (TODO) unregister ?

  /**
     * @private
     * Create a WebRTC connection.
     * @param {string} protocolId The identifier of the protocol that wishes to
     * establish an new connection.
     * @param {function|object} arg1 Either a callback function to send the
     * message to the remote peer (for instance, it can use a signaling server
     * or the already created WebRTC connexions), or a message received from the
     * remote peer.
     * @param {object} arg2 The message received from a peer that initialized a
     * WebRTC connection.
     */
  _connect (protocolId, arg1, arg2) {
    if (typeof arg1 === &apos;function&apos; &amp;&amp; typeof arg2 === &apos;undefined&apos;) {
      this._initiate(protocolId, arg1) // arg1: callback for offers
    } else if (typeof arg1 === &apos;function&apos; &amp;&amp; typeof arg2 !== &apos;undefined&apos;) {
      this._accept(protocolId, arg1, arg2) // arg1:callback, arg2:request
    } else {
      this._finalize(protocolId, arg1) // arg1: response
    }
  }

  /**
     * @private
     * Initiate the creation of a WebRTC connection. At this point, the identity
     * of the remote peer is unknown.
     * @param {string} protocolId The identifier of the protocol that creates a
     * connection.
     * @param {function} sender A function called at each offer
     */
  _initiate (protocolId, sender) {
    // #1 create an initiator
    this.options.config.initiator = true
    let SocketClass = this.options.socketClass
    let socket = new SocketClass(this.options.config)
    // #2 insert the new entry in the pending table
    let entry = new EPending(uuid(), null, protocolId, socket)
    // entry.tid = peerIdToConnectWith || entry.tid
    this.pending.set(entry.tid, entry)

    // #3 define events
    socket.once(&apos;connect&apos;, () =&gt; {
      entry.successful = true
      if (this.living.contains(entry.peer)) {
        entry.alreadyExists = true
        entry.successful = true
        this.living.insert(entry.peer, protocolId)
        debug(&apos;[%s] --- arc --&gt; %s&apos;, this.PEER, entry.peer)
        this.protocols.get(protocolId)._connected(entry.peer, true)
        entry.peer = null // becomes the unknown soldier
      } else {
        this.living.insert(entry.peer, protocolId, socket)
        debug(&apos;[%s] --- WebRTC --&gt; %s&apos;, this.PEER, entry.peer)
        this.protocols.get(protocolId)._connected(entry.peer, true)
      };

      this._checkPendingEntry(entry)
    })
    socket.once(&apos;close&apos;, () =&gt; {
      if (entry.peer !== null) { // if not the unknown soldier
        if (this.living.contains(entry.peer)) {
          // #A remove the socket from the table of living connections
          let toNotify = this.living.removePeer(entry.peer)
          // #B notify all protocols that were using this socket
          toNotify.forEach((occ, pid) =&gt; {
            for (let i = 0; i &lt; occ; ++i) {
              this.protocols.get(pid)._disconnected(entry.peer)
            };
          })
        } else if (this.dying.has(entry.peer)) {
          let d = this.dying.get(entry.peer)
          clearTimeout(d.timeout)
          this.dying.delete(entry.peer)
        };
        debug(&apos;[%s] -&#x2021;- WebRTC -&#x2021;&gt; %s&apos;, this.PEER, entry.peer)
      } else {
        debug(&apos;[%s] -&#x2021;- WebRTC -&#x2021;&gt; %s&apos;, this.PEER, &apos;unknown&apos;)
      };
      this._checkPendingEntry(entry)
    })

    socket.on(&apos;data&apos;, (d) =&gt; {
      let msg = this.decode(d)
      this.protocols.get(msg.pid)._received(msg.peer, msg.payload)
    })
    socket.on(&apos;stream&apos;, (s) =&gt; {
      this.protocols.get(entry.pid)._streamed(entry.peer, s)
    })
    socket.on(&apos;error&apos;, (e) =&gt; {
      // Nothing here, for the failure are detected and handled after
      // this.options.timeout milliseconds.
      debug(e)
      socket.destroy()
    })
    // #4 send offer message using sender
    socket.on(&apos;signal&apos;, (offer) =&gt; {
      if (socket.connected &amp;&amp; socket._isNegotiating) {
        sender(new MRequest(entry.tid, this.PEER, protocolId, offer, &apos;renegociate&apos;))
      } else {
        sender(new MRequest(entry.tid, this.PEER, protocolId, offer))
      }
    })

    // #5 check if the socket has been established correctly
    setTimeout(() =&gt; {
      // (TODO) on destroy notify protocols that still use the socket
      // (TODO) send MDisconnect messages to notify remote peer of the
      // removal of an arc
      (!entry.successful || entry.alreadyExists) &amp;&amp; (entry.socket !== null) &amp;&amp; entry.socket.destroy()
      !entry.successful &amp;&amp; this.protocols.get(protocolId)._failed(entry.peer, true)
      this.pending.delete(entry.tid)
    }, this.options.pendingTimeout)
  };

  /**
     * @private
     * Try to finalize the WebRTC connection using the remote offers.
     * @param {string} protocolId The identifier of the protocol that wishes to
     * open a connection.
     * @param {MResponse} msg The message containing an offer, a peerId etc.
     */
  _finalize (protocolId, msg) {
    if (msg.offerType === &apos;renegociate&apos;) {
      debug(`[%s] _finalize regenociation:`, msg)
      if (this.living.store.has(msg.peer)) {
        const socket = this.living.get(msg.peer).socket
        socket.connected &amp;&amp; !socket._isNegociating &amp;&amp; socket.signal(msg.offer)
      }
      return
    }
    if (!this.pending.has(msg.tid)) {
      // debug(new ExLateMessage(&apos;_finalize&apos;, msg))
      return
    };

    let entry = this.pending.get(msg.tid)
    if (entry) {
      if (entry.alreadyExists || entry.successful) {
        this._checkPendingEntry(entry)
        debug(&apos;The socket already exists: &apos;, entry.peer)
        return
      }
    }

    // #A check if the connection already exists
    if (this.living.contains(msg.peer)) {
      entry.alreadyExists = true
      entry.successful = true
      this.living.insert(msg.peer, protocolId)
      debug(&apos;[%s] --- arc --&gt; %s&apos;, this.PEER, msg.peer)
      this.protocols.get(protocolId)._connected(msg.peer, true)

      this._checkPendingEntry(entry)
    } else if (this.dying.has(msg.peer)) {
      // #B rise from the dead
      entry.alreadyExists = true
      entry.successful = true
      let rise = this.dying.get(msg.peer)
      clearTimeout(rise.timeout)
      this.dying.delete(msg.peer)
      this.living.insert(msg.peer, protocolId, rise.socket)
      debug(&apos;[%s] -&#xA1;- arc -&#xA1;&gt; %s&apos;, this.PEER, msg.peer)
      this.protocols.get(protocolId)._connected(msg.peer, true)

      this._checkPendingEntry(entry)
    } else {
      // #C just signal the offer
      entry.peer = msg.peer
      if (!msg.offer) {
        throw new ExIncompleteMessage(&apos;_finalize&apos;, entry, msg)
      } else {
        entry.socket.signal(msg.offer)
      };
    };
  };

  /**
     * @private
     * Establish a connection in response to the request of remote peer.
     * @param {string} protocolId The identifier of the protocol that wishes to
     * create a connection.
     * @param {function} sender The function that send the offer to the remote
     * initiating peer.
     * @param {MRequest} msg The request message containing offers, peerId, etc.
     **/
  _accept (protocolId, sender, msg) {
    if (msg.offerType === &apos;renegociate&apos;) {
      debug(`[%s] _accept regenociation:`, msg)
      if (this.living.store.has(msg.peer)) {
        this.living.get(msg.peer).socket.signal(msg.offer)
      }
      return
    }
    // #1 initialize the entry if it does not exist
    let firstCall = false
    const tid = msg.tid
    const peer = msg.peer
    if (!this.pending.has(tid)) {
      firstCall = true
      let entry = new EPending(tid, peer, protocolId)
      this.pending.set(tid, entry)

      setTimeout(() =&gt; {
        (!entry.successful || entry.alreadyExists) &amp;&amp; entry.socket &amp;&amp; entry.socket.destroy()
        !entry.successful &amp;&amp; this.protocols.get(protocolId)._failed(peer, false)
        this.pending.delete(tid)
      }, this.options.pendingTimeout)
    }

    // #2 check if a WebRTC connection to peerId already exists
    let entry = this.pending.get(msg.tid)
    // let entry = this.pending.get(peer);
    if (entry.alreadyExists || entry.successful) { return };

    // #A check if the connection already exists
    if (this.living.contains(msg.peer)) {
      entry.alreadyExists = true
      entry.successful = true
      this.living.insert(msg.peer, protocolId)
      debug(&apos;[%s] &lt;-- arc --- %s&apos;, this.PEER, entry.peer)
      this.protocols.get(protocolId)._connected(msg.peer, false)
      firstCall &amp;&amp; sender(new MResponse(entry.tid, this.PEER, protocolId, null))

      this._checkPendingEntry(entry)
    } else if (this.dying.has(msg.peer)) {
      // #B rise from the dead
      entry.alreadyExists = true
      entry.successful = true
      let rise = this.dying.get(msg.peer)
      clearTimeout(rise.timeout)
      this.dying.delete(msg.peer)
      this.living.insert(msg.peer, protocolId, rise.socket)
      debug(&apos;[%s] &lt;&#xA1;- arc -&#xA1;- %s&apos;, this.PEER, msg.peer)
      this.protocols.get(protocolId)._connected(msg.peer, false)
      firstCall &amp;&amp; sender(new MResponse(entry.tid, this.PEER, protocolId, null))

      // delete the pending entry cause we do not use the created one if exists
      this._checkPendingEntry(entry)
    } else {
      // #3 create the events and signal the offer
      if (firstCall &amp;&amp; !entry.socket) {
        // #A create a socket
        this.options.config.initiator = false
        let SocketClass = this.options.socketClass
        let socket = new SocketClass(this.options.config)
        // #B update the entry
        entry.socket = socket
        // #C define events
        socket.once(&apos;connect&apos;, () =&gt; {
          entry.successful = true
          if (this.living.contains(entry.peer)) {
            entry.alreadyExists = true
            entry.successful = true
            this.living.insert(entry.peer, protocolId)
            debug(&apos;[%s] &lt;-- arc --- %s&apos;, this.PEER, entry.peer)
            this.protocols.get(protocolId)._connected(entry.peer,
              false)
            entry.peer = null // becomes the unknown soldier
          } else {
            this.living.insert(entry.peer, protocolId, socket)
            debug(&apos;[%s] &lt;-- WebRTC --- %s&apos;, this.PEER, entry.peer)
            this.protocols.get(protocolId)._connected(entry.peer,
              false)
          };

          this._checkPendingEntry(entry)
        })
        socket.once(&apos;close&apos;, () =&gt; {
          if (entry.peer !== null) { // if not the unknown soldier
            if (this.living.contains(entry.peer)) {
              // #A remove the socket from the table of
              // living connections
              let toNotify = this.living.removePeer(entry.peer)
              // #B notify all protocols that were using
              // this socket
              toNotify.forEach((occ, pid) =&gt; {
                for (let i = 0; i &lt; occ; ++i) {
                  this.protocols.get(pid)
                    ._disconnected(entry.peer)
                };
              })
            } else if (this.dying.has(entry.peer)) {
              let d = this.dying.get(entry.peer)
              clearTimeout(d.timeout)
              this.dying.delete(entry.peer)
            };
            debug(&apos;[%s] &lt;&#x2021;- WebRTC -&#x2021;- %s&apos;, this.PEER, entry.peer)
          } else {
            debug(&apos;[%s] &lt;&#x2021;- WebRTC -&#x2021;- %s&apos;, this.PEER, &apos;unknown&apos;)
          };
          this._checkPendingEntry(entry)
        })

        socket.on(&apos;data&apos;, (d) =&gt; {
          let msg = this.decode(d)
          this.protocols.get(msg.pid)._received(msg.peer, msg.payload)
        })
        socket.on(&apos;stream&apos;, (s) =&gt; {
          this.protocols.get(entry.pid)._streamed(entry.peer, s)
        })
        socket.on(&apos;error&apos;, (e) =&gt; {
          // Nothing here, for the failure are detected and handled
          // after this.options.timeout milliseconds.
          debug(e)
          socket.destroy()
        })
        // #4 send offer message using sender
        socket.on(&apos;signal&apos;, (offer) =&gt; {
          if (socket.connected &amp;&amp; !socket._isNegotiating) {
            sender(new MResponse(entry.tid, this.PEER, protocolId, offer, &apos;renegociate&apos;))
          } else {
            sender(new MResponse(entry.tid, this.PEER, protocolId, offer))
          }
        })
      };
      entry.socket.signal(msg.offer)
    };
  };

  /**
     * @private
     * Remove an arc from protocolId leading to peerId. If it was the last arc,
     * the WebRTC connexion is downgraded to the dying table. In this table, the
     * connexion will be closed if none create it.
     * @param {string} protocolId The identifier of the protocol that removes an
     * arc
     * @param {string|undefined} peerId The identifier of the peer. If no arg,
     * remove all arcs of protocolId.
     */
  _disconnect (protocolId, peerId) {
    if (typeof peerId === &apos;undefined&apos;) {
      // #1 remove all arcs
      var entries = this.living.removeAll(protocolId)
      entries.forEach((entry) =&gt; {
        if (entry.socket !== null) {
          var dying = new EDying(entry.peer,
            entry.socket,
            setTimeout(() =&gt; {
              entry.socket &amp;&amp; entry.socket.destroy()
            }, this.options.timeout))
          this.dying.set(dying.peer, dying)
        };

        for (let i = 0; i &lt; entry.occ; ++i) {
          if (entry.socket === null ||
                        (entry.socket !== null &amp;&amp; i &lt; entry.occ - 1)) {
            debug(&apos;[%s] &#x2020;&#x2020;&#x2020; arc &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
          } else {
            debug(&apos;[%s] &#x2020;&#x2020;&#x2020; WebRTC &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
          };
          this.protocols.get(protocolId)._disconnected(entry.peer)
        };
      })
    } else {
      var entry = null
      // #2 remove one arc
      try {
        entry = this.living.remove(peerId, protocolId)
      } catch (e) {
        console.log(e) // dangerous
        // noop
      }
      if (entry) {
        var dying = new EDying(entry.peer, entry.socket, setTimeout(() =&gt; {
          entry.socket &amp;&amp; entry.socket.destroy()
        }, this.options.timeout))
        this.dying.set(dying.peer, dying)
        debug(&apos;[%s] &#x2020;&#x2020;&#x2020; WebRTC &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
      } else {
        debug(&apos;[%s] &#x2020;&#x2020;&#x2020; arc &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
      };
      this.protocols.get(protocolId)._disconnected(peerId)
    };
  };

  /**
     * @private
     * Send a message to a remote peer. It encapsulates the message
     * from protocolId to help the remote peer to route the message to the
     * proper protocol.
     * @param {string} protocolId The identifier of the protocol sending the
     * message
     * @param {string} peerId The remote peer to send the message to.
     * @param {object} message The message to send.
     * @param {number} [retry=0] Retry few times to send the message before
     * giving up.
     * @returns {promise} Resolved when the message is sent, reject
     * otherwise. Note that loss of messages is not handled by default.
     */
  _send (protocolId, peerId, message, retry = 0) {
    return new Promise((resolve, reject) =&gt; {
      // #1 get the proper entry in the tables
      let entry = null
      if (this.living.contains(peerId)) {
        entry = this.living.get(peerId)
      } else if (this.dying.has(peerId)) {
        entry = this.dying.get(peerId) // (TODO) warn: not safe
      };
      if (entry === null) {
        // console.log(protocolId, peerId, message, retry, this.living.store.size, this.dying.size)
        reject(new Error(&apos;peer not found: &apos; + peerId))
      }
      // #2 define the recursive sending function
      let __send = (r) =&gt; {
        try {
          entry.socket.send(this.encode(new MSend(this.PEER,
            protocolId,
            message)))
          debug(&apos;[%s] --- msg --&gt; %s:%s&apos;,
            this.PEER, peerId, protocolId)
          resolve()
        } catch (e) {
          debug(&apos;[%s] -X- msg -X&gt; %s:%s&apos;,
            this.PEER, peerId, protocolId)
          if (r &lt; retry) {
            setTimeout(() =&gt; { __send(r + 1) }, 1000)
          } else {
            reject(e)
          };
        };
      }
      // #3 start to send
      __send(0)
    })
  };

  _checkPendingEntry (entry) {
    if (this.pending.has(entry.tid)) {
      if (entry.peer === null) {
        if (entry.socket) {
          entry.socket.destroy()
          entry.socket = null
        }
      }
      this.pending.delete(entry.tid)
    }
  }
};

module.exports = Neighborhood
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
