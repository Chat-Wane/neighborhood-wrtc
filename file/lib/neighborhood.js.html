<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/neighborhood.js | neighborhood-wrtc</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="neighborhood (or partial view) containing peers to communicate with"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="neighborhood-wrtc"><meta property="twitter:description" content="neighborhood (or partial view) containing peers to communicate with"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ran3d/neighborhood-wrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/arcstore.js~ArcStore.html">ArcStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/iprotocol.js~IProtocol.html">IProtocol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/neighborhood.js~Neighborhood.html">Neighborhood</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#entries">entries</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/edying.js~EDying.html">EDying</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/eliving.js~ELiving.html">ELiving</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/epending.js~EPending.html">EPending</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#exceptions">exceptions</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exincompletemessage.js~ExIncompleteMessage.html">ExIncompleteMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exlatemessage.js~ExLateMessage.html">ExLateMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exprotocolexists.js~ExProtocolExists.html">ExProtocolExists</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exsocketnotfound.js~ExSocketNotFound.html">ExSocketNotFound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exundefinedfunction.js~ExUndefinedFunction.html">ExUndefinedFunction</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#messages">messages</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/minternalsend.js~MInternalSend.html">MInternalSend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mrequest.js~MRequest.html">MRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mresponse.js~MResponse.html">MResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/msend.js~MSend.html">MSend</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/neighborhood.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

const debug = (require(&apos;debug&apos;))(&apos;neighborhood-wrtc&apos;)

const merge = require(&apos;lodash.merge&apos;)
const uuid = require(&apos;uuid/v4&apos;)
const Socket = require(&apos;simple-peer&apos;)
const Events = require(&apos;events&apos;)

const ArcStore = require(&apos;./arcstore.js&apos;)
const EPending = require(&apos;./entries/epending.js&apos;)
const EDying = require(&apos;./entries/edying.js&apos;)

const MResponse = require(&apos;./messages/mresponse.js&apos;)
const MRequest = require(&apos;./messages/mrequest.js&apos;)
const MSend = require(&apos;./messages/msend.js&apos;)
const MInternalSend = require(&apos;./messages/minternalsend.js&apos;)

const ExIncompleteMessage = require(&apos;./exceptions/exincompletemessage.js&apos;)

/**
 * Easy-to-use interface to establish multiple WebRTC connections using
 * SimplePeer (npm: simple-peer)
 */
class Neighborhood extends Events {
  /**
     * @param {object} [options] the options available to the connections, e.g.
     * timeout before
     * @param {object} [options.socketClass] simple-peer default socket class (usefull if you need to change the type of socket)
     * @param {object} [options.config] simple-peer options
     * @param {number} [options.timeout = 60000] Time to wait (in milliseconds) for dying socket
     * @param {number} [options.pendingTimeout = 10000] Time to wait (in milliseconds) for pending socket
     * before neighborhood-wrtc assumes that a connection establishment failed,
     * or before an unused connection is removed.
     * @param {function} [options.encoding] Method to customize message sent,
     * default: return JSON.stringify(data);
     * @param {function} [options.decoding] Method to decode a received message,
     * default: return JSON.parse(data);
     */
  constructor (options) {
    super()
    // #1 save options
    this.options = {
      socketClass: Socket,
      peer: uuid(),
      config: { trickle: true, initiator: false },
      timeout: 1 * 60 * 1000,
      pendingTimeout: 10 * 1000,
      encoding: (d) =&gt; { return JSON.stringify(d) },
      decoding: (d) =&gt; { return JSON.parse(d) }
    }
    this.options = merge(this.options, options)
    this.encode = this.options.encoding // not sure it should stay that
    this.decode = this.options.decoding // way

    // #2 unmutable values
    this.PEER = this.options.peer
    debug(&apos;[%s] initialized.&apos;, this.PEER)

    // #3 initialize tables
    this.pending = new Map() // not finalized yet
    this.living = new ArcStore() // live and usable
    this.dying = new Map() // being removed
  }

  /**
   * Create a WebRTC connection.
   * @param {function|object} arg1 Either a callback function to send the
   * message to the remote peer (for instance, it can use a signaling server
   * or the already created WebRTC connexions), or a message received from the
   * remote peer.
   * @param {object} arg2 The message received from a peer that initialized a
   * WebRTC connection.
   */
  connect (arg1, arg2) {
    return new Promise((resolve, reject) =&gt; {
      const id = uuid()
      if (typeof arg1 === &apos;function&apos; &amp;&amp; typeof arg2 === &apos;undefined&apos;) {
        this._initiate(arg1, id) // arg1: callback for offers
      } else if (typeof arg1 === &apos;function&apos; &amp;&amp; typeof arg2 !== &apos;undefined&apos;) {
        this._accept(arg1, arg2, id) // arg1:callback, arg2:request
      } else {
        this._finalize(arg1, id) // arg1: response
      }
      this.once(id, (connectedWith, timeout = false) =&gt; {
        if (timeout) reject(new Error(&apos;timeout exceeded.&apos;))
        resolve(connectedWith)
      })
    })
  }

  /**
   * @private
   * Initiate the creation of a WebRTC connection. At this point, the identity
   * of the remote peer is unknown.
   * @param {function} sender A function called at each offer
   * @param {String} jobId The jobId that initiate the connection
   */
  _initiate (sender, jobId) {
    // #1 create an initiator
    this.options.config.initiator = true
    let SocketClass = this.options.socketClass
    let socket = new SocketClass(this.options.config)
    // #2 insert the new entry in the pending table
    let entry = new EPending(uuid(), null, socket)
    entry.jobId = jobId
    // entry.tid = peerIdToConnectWith || entry.tid
    this.pending.set(entry.tid, entry)

    // #3 define events
    socket.once(&apos;connect&apos;, () =&gt; {
      entry.successful = true
      if (this.living.contains(entry.peer)) {
        entry.alreadyExists = true
        entry.successful = true
        debug(&apos;[_initiate(connect/living)] insert/increment&apos;)
        const inserting = this.living.insert(entry.peer, undefined, entry.tid)
        if (inserting) {
          debug(&apos;[init] emit connect event: &apos;, entry.jobId, entry.peer, false)
          this.emit(entry.jobId, entry.peer, false)
          // notify
          this._connected(entry.peer, true)
        }
        entry.peer = null // becomes the unknown soldier
      } else {
        debug(&apos;[_initiate(connect)] insert/increment&apos;)
        const inserting = this.living.insert(entry.peer, socket, entry.tid)
        if (inserting) {
          debug(&apos;[init] emit connect event: &apos;, entry.jobId, entry.peer, false)
          this.emit(entry.jobId, entry.peer, false)
          // notify
          this._connected(entry.peer, true)
        }
      }

      this._checkPendingEntry(entry)
    })
    socket.once(&apos;close&apos;, () =&gt; {
      if (entry.peer !== null) { // if not the unknown soldier
        if (this.living.contains(entry.peer)) {
          // #A remove the socket from the table of living connections
          this.living.removePeer(entry.peer)
          // #B notify
          this._disconnected(entry.peer)
        } else if (this.dying.has(entry.peer)) {
          let d = this.dying.get(entry.peer)
          clearTimeout(d.timeout)
          this.dying.delete(entry.peer)
        }
        debug(&apos;[init] emit close event: &apos;, entry.jobId, entry.peer, true)
        this._checkPendingEntry(entry)
        this.emit(entry.jobId, entry.peer, true)
      } else {
        debug(&apos;[%s] -&#x2021;- WebRTC -&#x2021;&gt; %s&apos;, this.PEER, &apos;unknown&apos;)
      }
    })

    socket.on(&apos;data&apos;, (d) =&gt; {
      let msg = this.decode(d)
      if (msg.type === &apos;MInternalSend&apos;) {
        this._receiveInternalMessage(msg)
      } else {
        this._received(msg.peer, msg.payload)
      }
    })
    socket.on(&apos;stream&apos;, (s) =&gt; {
      this._streamed(entry.peer, s)
    })
    socket.on(&apos;error&apos;, (e) =&gt; {
      // Nothing here, for the failure are detected and handled after
      // this.options.timeout milliseconds.
      debug(e)
      socket.destroy()
      debug(&apos;[init] emit error event: &apos;, entry.jobId, entry.peer, true)
      this.emit(entry.jobId, entry.peer, true)
    })
    // #4 send offer message using sender
    socket.on(&apos;signal&apos;, (offer) =&gt; {
      if (socket.connected &amp;&amp; !socket._isNegociating) {
        this._sendRenegociateRequest(new MRequest(entry.tid, this.PEER, offer, &apos;renegociate&apos;), entry.peer)
      } else {
        sender(new MRequest(entry.tid, this.PEER, offer))
      }
    })

    // #5 check if the socket has been established correctly
    setTimeout(() =&gt; {
      if ((!entry.successful || entry.alreadyExists) &amp;&amp; (entry.socket !== null)) {
        entry.socket.destroy()
      }
      if (!entry.successful) {
        this._failed(entry.peer, true)
        debug(&apos;[init] emit timeout event: &apos;, entry.jobId, entry.peer, true)
        this.emit(entry.jobId, entry.peer, true)
      }
      this.pending.delete(entry.tid)
    }, this.options.pendingTimeout)
  }

  /**
     * @private
     * Try to finalize the WebRTC connection using the remote offers.
     * @param {MResponse} msg The message containing an offer, a peerId etc.
     */
  _finalize (msg) {
    if (msg.offerType === &apos;renegociate&apos;) {
      debug(`[%s] _finalize regenociation:`, msg)
      if (this.living.store.has(msg.peer)) {
        const socket = this.living.get(msg.peer).socket
        socket.connected &amp;&amp; !socket._isNegociating &amp;&amp; socket.signal(msg.offer)
      }
      return
    }
    if (!this.pending.has(msg.tid)) {
      // debug(new ExLateMessage(&apos;_finalize&apos;, msg))
      return
    }

    let entry = this.pending.get(msg.tid)
    if (entry) {
      if (entry.alreadyExists || entry.successful) {
        this._checkPendingEntry(entry)
        debug(&apos;The socket already exists: &apos;, entry.peer)
        return
      }
    }
    // #A check if the connection already exists
    if (this.living.contains(msg.peer)) {
      entry.alreadyExists = true
      entry.successful = true
      debug(&apos;[_finalize(living exists)] insert/increment&apos;)
      const inserting = this.living.insert(msg.peer, undefined, msg.tid)
      if (inserting) {
        debug(&apos;[%s]finalize --- arc --&gt; %s&apos;, this.PEER, msg.peer)
        this._connected(msg.peer, true)
        this.emit(entry.jobId, msg.peer, false)
      }
      this._checkPendingEntry(entry)
    } else if (this.dying.has(msg.peer)) {
      debug(&apos;[_finalize(dying exists)] insert/increment&apos;)
      // #B rise from the dead
      entry.alreadyExists = true
      entry.successful = true
      let rise = this.dying.get(msg.peer)
      clearTimeout(rise.timeout)
      this.dying.delete(msg.peer)
      const inserting = this.living.insert(msg.peer, rise.socket, msg.tid)
      if (inserting) {
        debug(&apos;[%s]finalize -&#xA1;- arc -&#xA1;&gt; %s&apos;, this.PEER, msg.peer)
        this._connected(msg.peer, true)
        this.emit(entry.jobId, msg.peer, false)
      }
      this._checkPendingEntry(entry)
    } else {
      // #C just signal the offer
      entry.peer = msg.peer
      if (!msg.offer) {
        throw new ExIncompleteMessage(&apos;_finalize&apos;, entry, msg)
      } else {
        debug(&apos;[finalize] signaling: &apos;, msg)
        entry.socket.signal(msg.offer)
      }
    }
  }

  /**
     * @private
     * Establish a connection in response to the request of remote peer.
     * @param {function} sender The function that send the offer to the remote
     * initiating peer.
     * @param {MRequest} msg The request message containing offers, peerId, etc.
     **/
  _accept (sender, msg) {
    if (msg.offerType === &apos;renegociate&apos;) {
      debug(`[%s] _accept regenociation:`, msg)
      if (this.living.store.has(msg.peer)) {
        this.living.get(msg.peer).socket.signal(msg.offer)
      }
      return
    }
    // #1 initialize the entry if it does not exist
    let firstCall = false
    const tid = msg.tid
    const peer = msg.peer
    if (!this.pending.has(tid)) {
      firstCall = true
      let entry = new EPending(tid, peer)
      this.pending.set(tid, entry)

      setTimeout(() =&gt; {
        (!entry.successful || entry.alreadyExists) &amp;&amp; entry.socket &amp;&amp; entry.socket.destroy()
        !entry.successful &amp;&amp; this._failed(peer, false)
        this.pending.delete(tid)
      }, this.options.pendingTimeout)
    }

    // #2 check if a WebRTC connection to peerId already exists
    let entry = this.pending.get(msg.tid)
    // let entry = this.pending.get(peer)
    if (entry.alreadyExists || entry.successful) { return }

    // #A check if the connection already exists
    if (this.living.contains(msg.peer)) {
      entry.alreadyExists = true
      entry.successful = true
      debug(&apos;[_accept(living exists)] insert/increment&apos;, msg)
      const inserting = this.living.insert(msg.peer, undefined, msg.tid)
      if (inserting) {
        debug(&apos;[%s] &lt;-- arc --- %s&apos;, this.PEER, entry.peer)
        this._connected(msg.peer, false)
      }
      firstCall &amp;&amp; sender(new MResponse(entry.tid, this.PEER, null))

      this._checkPendingEntry(entry)
    } else if (this.dying.has(msg.peer)) {
      debug(&apos;[_accept(dying exists)] insert/increment&apos;, msg)
      // #B rise from the dead
      entry.alreadyExists = true
      entry.successful = true
      let rise = this.dying.get(msg.peer)
      clearTimeout(rise.timeout)
      this.dying.delete(msg.peer)
      const inserting = this.living.insert(msg.peer, rise.socket, msg.tid)
      if (inserting) {
        debug(&apos;[%s] &lt;&#xA1;- arc -&#xA1;- %s&apos;, this.PEER, msg.peer)
        this._connected(msg.peer, false)
      }
      firstCall &amp;&amp; sender(new MResponse(entry.tid, this.PEER, null))

      // delete the pending entry cause we do not use the created one if exists
      this._checkPendingEntry(entry)
    } else {
      // #3 create the events and signal the offer
      if (firstCall &amp;&amp; !entry.socket) {
        // #A create a socket
        this.options.config.initiator = false
        let SocketClass = this.options.socketClass
        let socket = new SocketClass(this.options.config)
        // #B update the entry
        entry.socket = socket
        // #C define events
        socket.once(&apos;connect&apos;, () =&gt; {
          entry.successful = true
          if (this.living.contains(entry.peer)) {
            entry.alreadyExists = true
            entry.successful = true
            debug(&apos;[_accept(connect/living)] insert/increment&apos;)
            const inserting = this.living.insert(entry.peer, undefined, msg.tid)
            if (inserting) {
              debug(&apos;[%s] &lt;-- arc --- %s&apos;, this.PEER, entry.peer)
              this._connected(entry.peer, false)
            }
            entry.peer = null // becomes the unknown soldier
          } else {
            debug(&apos;[_accept(connect/dying)] insert/increment&apos;)
            const inserting = this.living.insert(entry.peer, socket, msg.tid)
            if (inserting) {
              debug(&apos;[%s] &lt;-- WebRTC --- %s&apos;, this.PEER, entry.peer)
              this._connected(entry.peer, false)
            }
          }

          this._checkPendingEntry(entry)
        })
        socket.once(&apos;close&apos;, () =&gt; {
          if (entry.peer !== null) { // if not the unknown soldier
            if (this.living.contains(entry.peer)) {
              // #A remove the socket from the table of
              // living connections
              this.living.removePeer(entry.peer)
              this._disconnected(entry.peer)
            } else if (this.dying.has(entry.peer)) {
              let d = this.dying.get(entry.peer)
              clearTimeout(d.timeout)
              this.dying.delete(entry.peer)
            }
            debug(&apos;[%s] &lt;&#x2021;- WebRTC -&#x2021;- %s&apos;, this.PEER, entry.peer)
          } else {
            debug(&apos;[%s] &lt;&#x2021;- WebRTC -&#x2021;- %s&apos;, this.PEER, &apos;unknown&apos;)
          }
          this._checkPendingEntry(entry)
        })

        socket.on(&apos;data&apos;, (d) =&gt; {
          let msg = this.decode(d)
          if (msg.type === &apos;MInternalSend&apos;) {
            this._receiveInternalMessage(msg)
          } else {
            this._received(msg.peer, msg.payload)
          }
        })
        socket.on(&apos;stream&apos;, (s) =&gt; {
          this._streamed(entry.peer, s)
        })
        socket.on(&apos;error&apos;, (e) =&gt; {
          // Nothing here, for the failure are detected and handled
          // after this.options.timeout milliseconds.
          debug(e)
          socket.destroy()
        })
        // #4 send offer message using sender
        socket.on(&apos;signal&apos;, (offer) =&gt; {
          if (socket.connected &amp;&amp; !socket._isNegotiating) {
            this._sendRenegociateResponse(new MResponse(entry.tid, this.PEER, offer, &apos;renegociate&apos;), entry.peer)
          } else {
            sender(new MResponse(entry.tid, this.PEER, offer))
          }
        })
      }
      entry.socket.signal(msg.offer)
    }
  }

  /**
     * Remove an arc. If it was the last arc,
     * the WebRTC connexion is downgraded to the dying table. In this table, the
     * connexion will be closed if none create it.
     * @param {string|undefined} peerId The identifier of the peer. If no arg,
     * remove all arcs.
     */
  disconnect (peerId) {
    return new Promise((resolve, reject) =&gt; {
      if (typeof peerId === &apos;undefined&apos;) {
        // #1 remove all arcs
        let entries
        try {
          entries = this.living.removeAll()
        } catch (e) {
          return reject(e)
        }
        entries.forEach((entry) =&gt; {
          if (entry.socket !== null) {
            let dying = new EDying(entry.peer, entry.socket,
              setTimeout(() =&gt; {
                entry.socket &amp;&amp; entry.socket.destroy()
              }, this.options.timeout))
            this.dying.set(dying.peer, dying)
          }

          for (let i = 0; i &lt; entry.occ; ++i) {
            if (entry.socket === null || (entry.socket !== null &amp;&amp; i &lt; entry.occ - 1)) {
              debug(&apos;DISCONNECT-ALL [%s] &#x2020;&#x2020;&#x2020; arc &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
            } else {
              debug(&apos;DISCONNECT-ALL [%s] &#x2020;&#x2020;&#x2020; WebRTC &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
            }
            this._disconnected(entry.peer)
          }
        })
        resolve()
      } else {
        let entry = null
        // #2 remove one arc
        try {
          entry = this.living.remove(peerId)
        } catch (e) {
          return reject(e)
        }
        if (entry) {
          let dying = new EDying(entry.peer, entry.socket, setTimeout(() =&gt; {
            entry.socket &amp;&amp; entry.socket.destroy()
          }, this.options.timeout))
          this.dying.set(dying.peer, dying)
          debug(&apos;DISCONNECT-ONE [%s] &#x2020;&#x2020;&#x2020; WebRTC &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
        } else {
          debug(&apos;DISCONNECT-ONE [%s] &#x2020;&#x2020;&#x2020; arc &#x2020;&#x2020;&#x2020; %s&apos;, this.PEER, peerId)
        }
        this._disconnected(peerId)
        resolve()
      }
    })
  }

  /**
     * Send a message to a remote peer.
     * @param {string} peerId The remote peer to send the message to.
     * @param {object} message The message to send.
     * @param {number} [retry=0] Retry few times to send the message before
     * giving up.
     * @returns {promise} Resolved when the message is sent, reject
     * otherwise. Note that loss of messages is not handled by default.
     */
  send (peerId, message, retry = 0) {
    return new Promise((resolve, reject) =&gt; {
      // #1 get the proper entry in the tables
      let entry = null
      if (this.living.contains(peerId)) {
        entry = this.living.get(peerId)
      } else if (this.dying.has(peerId)) {
        entry = this.dying.get(peerId) // (TODO) warn: not safe
      }
      if (entry === null) {
        return reject(new Error(&apos;peer not found: &apos; + peerId))
      }
      // #2 define the recursive sending function
      let __send = (r) =&gt; {
        try {
          entry.socket.send(this.encode(new MSend(this.PEER, message)))
          debug(&apos;[%s] --- msg --&gt; %s:%s&apos;, this.PEER, peerId)
          resolve()
        } catch (e) {
          debug(&apos;[%s] -X- msg -X&gt; %s:%s&apos;, this.PEER, peerId)
          if (r &lt; retry) {
            setTimeout(() =&gt; { __send(r + 1) }, 1000)
          } else {
            return reject(e)
          }
        }
      }
      // #3 start to send
      __send(0)
    })
  }

  stream (peerId, media, retry = 0) {
    return new Promise((resolve, reject) =&gt; {
      // #1 get the proper entry in the tables
      let entry = null
      if (this.living.contains(peerId)) {
        entry = this.living.get(peerId)
      } else if (this.dying.has(peerId)) {
        entry = this.dying.get(peerId) // (TODO) warn: not safe
      }
      if (entry === null) {
        this.living.store.forEach(elem =&gt; {
          debug(elem.peer)
        })
        reject(new Error(&apos;peer not found: &apos; + peerId))
      }
      // #2 define the recursive sending function
      let __send = (r) =&gt; {
        try {
          entry.socket.addStream(media)
          debug(&apos;[%s] --- MEDIA msg --&gt; %s:%s&apos;, this.PEER, peerId)
          resolve()
        } catch (e) {
          debug(&apos;[%s] -X- MEDIA msg -X&gt; %s:%s&apos;, this.PEER, peerId)
          if (r &lt; retry) {
            setTimeout(() =&gt; { __send(r + 1) }, 1000)
          } else {
            reject(e)
          }
        }
      }
      // #3 start to send
      __send(0)
    })
  }

  _sendRenegociateRequest (request, to, retry = 0) {
    return new Promise((resolve, reject) =&gt; {
      // #1 get the proper entry in the tables
      let entry = null
      if (this.living.contains(to)) {
        entry = this.living.get(to)
      } else if (this.dying.has(to)) {
        entry = this.dying.get(to) // (TODO) warn: not safe
      }
      if (entry === null) {
        this.living.store.forEach(elem =&gt; {
          debug(elem.peer)
        })
        return reject(new Error(&apos;peer not found: &apos; + to))
      }
      // #2 define the recursive sending function
      let __send = (r) =&gt; {
        try {
          entry.socket.send(this.encode(new MInternalSend(this.PEER, request)))
          debug(&apos;[%s] --- MEDIA Internal Renegociate msg --&gt; %s:%s&apos;,
            this.PEER, to)
          resolve()
        } catch (e) {
          debug(&apos;[%s] -X- MEDIA Internal Renegociate msg -X&gt; %s:%s&apos;,
            this.PEER, to)
          if (r &lt; retry) {
            setTimeout(() =&gt; { __send(r + 1) }, 1000)
          } else {
            return reject(e)
          }
        }
      }
      // #3 start to send
      __send(0)
    })
  }

  _sendRenegociateResponse (response, to, retry = 0) {
    return new Promise((resolve, reject) =&gt; {
      // #1 get the proper entry in the tables
      let entry = null
      if (this.living.contains(to)) {
        entry = this.living.get(to)
      } else if (this.dying.has(to)) {
        entry = this.dying.get(to) // (TODO) warn: not safe
      }
      if (entry === null) {
        this.living.store.forEach(elem =&gt; {
          debug(elem.peer)
        })
        return reject(new Error(&apos;peer not found: &apos; + to))
      }
      // #2 define the recursive sending function
      let __send = (r) =&gt; {
        try {
          entry.socket.send(this.encode(new MInternalSend(this.PEER, response)))
          debug(&apos;[%s] --- MEDIA Internal Renegociate msg --&gt; %s:%s&apos;,
            this.PEER, to)
          resolve()
        } catch (e) {
          debug(&apos;[%s] -X- MEDIA Internal Renegociate msg -X&gt; %s:%s&apos;,
            this.PEER, to)
          if (r &lt; retry) {
            setTimeout(() =&gt; { __send(r + 1) }, 1000)
          } else {
            return reject(e)
          }
        }
      }
      // #3 start to send
      __send(0)
    })
  }

  _receiveInternalMessage (msg) {
    debug(&apos;Receive internal message: &apos;, msg)
    this.living.get(msg.peer).socket.signal(msg.payload.offer)
  }

  /**
   * return an array of living sockets
   * @return {[ELiving]} a living entry with socket, peer id and number of occurences (arcs)
   */
  neighbours () {
    const neigh = []
    this.living.store.forEach(elem =&gt; {
      neigh.push(elem)
    })
    return neigh
  }

  _checkPendingEntry (entry) {
    if (this.pending.has(entry.tid)) {
      if (entry.peer === null) {
        if (entry.socket) {
          entry.socket.destroy()
          entry.socket = null
        }
      }
      this.pending.delete(entry.tid)
    }
  }
}

module.exports = Neighborhood
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
