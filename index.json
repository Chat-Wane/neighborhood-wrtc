[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/arcstore.js",
    "content": "'use strict'\n\nconst ELiving = require('./entries/eliving.js')\n\nconst ExSocketNotFound = require('./exceptions/exsocketnotfound.js')\n\n/**\n * Table that contains all living sockets that might be in use. Peers can\n * comprise multiples protocols that may use multiple times an arc.\n */\nclass ArcStore {\n  constructor () {\n    this.store = new Map()\n  }\n\n  /**\n     * add another arc leading to peerId in the store\n     * @param {string} peerId The identifier of the peer reachable through the\n     * socket.\n     * @param {object} socket The WebRTC socket. Can be null if the socket to\n     * peerId is known to be in the store.\n     */\n  insert (peerId, socket) {\n    // #1 make sure the peerId exists if the socket is not set.\n    if (socket === null && !this.store.has(peerId)) {\n      throw new ExSocketNotFound(\n        'arcStore',\n        peerId,\n        'Try to add an arc to a peer that does not exists')\n    }\n\n    // #2 the peerId is not known yet, create the entry\n    if (!this.store.has(peerId)) {\n      let entry = new ELiving(peerId, socket)\n      this.store.set(peerId, entry)\n    } else {\n      // #3 increment the number of arcs of protocolId\n      this.store.get(peerId).increment()\n    }\n  }\n\n  /**\n     * ProtocolId removes an arc to the peerId.\n     * @param {string} peerId The identifier of the peer accessible through the\n     * arc to delete.\n     * @returns {ELiving} The entry if no protocol is using the socket, null\n     * otherwise.\n     */\n  remove (peerId) {\n    let unusedSocket = null\n    // #1 check if a socket to the arc exists\n    if (!this.store.has(peerId)) {\n      throw new ExSocketNotFound(\n        'arcStore',\n        peerId,\n        'Try to remove an arc to a peer that does not exists')\n    }\n    this.store.get(peerId).decrement()\n    // #3 remove the entry if no protocol use it\n    if (this.store.get(peerId).counter <= 0) {\n      unusedSocket = this.store.get(peerId)\n      this.store.delete(peerId)\n    }\n    return unusedSocket\n  }\n\n  /**\n     * removes all arcs.\n     * @returns {object[]} Objects comprising {peer, socket, occ}; peer being\n     * the identifier of the peer reachable through the socket, socket being a\n     * WebRTC connection that is not used by any protocols, null if protocols\n     * still use it, occ being the number of arcs removed by protocolId.\n     */\n  removeAll () {\n    let result = []\n    this.store.forEach((v, k) => {\n      let entry = {\n        peer: v.peer,\n        socket: null,\n        occ: v.counter\n      }\n      for (let i = 0; i < entry.occ; ++i) {\n        let unusedSocket = this.remove(k)\n        if (unusedSocket !== null) {\n          entry.socket = unusedSocket.socket\n          result.push(entry)\n        }\n      }\n    })\n    return result\n  }\n\n  /**\n     * Remove all arcs leading to peerId.\n     * @param {string} peerId The identifier of the peer reachable by a WebRTC\n     * connection to remove.\n     * @returns {Map} Map where key is the identifier of the protocol that sees\n     * its arcs being removed, and value is the number of arcs removed;\n     */\n  removePeer (peerId) {\n    let result\n    if (this.store.has(peerId)) {\n      result = this.store.get(peerId)\n      this.store.delete(peerId)\n    } else {\n      result = new Map()\n    }\n    return result\n  };\n  /**\n     * Check if the store has at least one occurrence of the peer.\n     * @param {string} peerId The identifier of the peer to check.\n     * @returns {boolean} true if it exists, false otherwise.\n     */\n  contains (peerId) {\n    return this.store.has(peerId)\n  }\n\n  /**\n     * Get the entry of the arc leading to PeerId\n     * @param {string} peerId The identifier of the remote peer\n     * @returns {ELiving} The entry containing peerId, null if it does not\n     * exists.\n     */\n  get (peerId) {\n    let entry = null\n    if (this.contains(peerId)) {\n      entry = this.store.get(peerId)\n    }\n    return entry\n  }\n}\n\nmodule.exports = ArcStore\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/arcstore.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "ArcStore",
    "memberof": "lib/arcstore.js",
    "static": true,
    "longname": "lib/arcstore.js~ArcStore",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/arcstore.js",
    "importStyle": "ArcStore",
    "description": "Table that contains all living sockets that might be in use. Peers can\ncomprise multiples protocols that may use multiple times an arc.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "store",
    "memberof": "lib/arcstore.js~ArcStore",
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#store",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "insert",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#insert",
    "access": "public",
    "description": "add another arc leading to peerId in the store",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\nsocket."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "socket",
        "description": "The WebRTC socket. Can be null if the socket to\npeerId is known to be in the store."
      }
    ],
    "return": null
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "remove",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#remove",
    "access": "public",
    "description": "ProtocolId removes an arc to the peerId.",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ELiving} The entry if no protocol is using the socket, null\notherwise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer accessible through the\narc to delete."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ELiving"
      ],
      "spread": false,
      "description": "The entry if no protocol is using the socket, null\notherwise."
    }
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "removeAll",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#removeAll",
    "access": "public",
    "description": "removes all arcs.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} Objects comprising {peer, socket, occ}; peer being\nthe identifier of the peer reachable through the socket, socket being a\nWebRTC connection that is not used by any protocols, null if protocols\nstill use it, occ being the number of arcs removed by protocolId."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Objects comprising {peer, socket, occ}; peer being\nthe identifier of the peer reachable through the socket, socket being a\nWebRTC connection that is not used by any protocols, null if protocols\nstill use it, occ being the number of arcs removed by protocolId."
    },
    "params": []
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "removePeer",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#removePeer",
    "access": "public",
    "description": "Remove all arcs leading to peerId.",
    "lineNumber": 100,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Map} Map where key is the identifier of the protocol that sees\nits arcs being removed, and value is the number of arcs removed;"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer reachable by a WebRTC\nconnection to remove."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Map"
      ],
      "spread": false,
      "description": "Map where key is the identifier of the protocol that sees\nits arcs being removed, and value is the number of arcs removed;"
    }
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "contains",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#contains",
    "access": "public",
    "description": "Check if the store has at least one occurrence of the peer.",
    "lineNumber": 115,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} true if it exists, false otherwise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it exists, false otherwise."
    }
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "get",
    "memberof": "lib/arcstore.js~ArcStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/arcstore.js~ArcStore#get",
    "access": "public",
    "description": "Get the entry of the arc leading to PeerId",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ELiving} The entry containing peerId, null if it does not\nexists."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the remote peer"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ELiving"
      ],
      "spread": false,
      "description": "The entry containing peerId, null if it does not\nexists."
    }
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "lib/entries/edying.js",
    "content": "'use strict'\n\n/**\n * Entry of the dying table containing sockets being removed.\n */\nclass EDying {\n  /**\n     * @param {string} peerId The identifier of the peer reachable through the\n     * socket.\n     * @param {object} socket The WebRTC socket.\n     * @param {number} timeout Time before the connexion is completely removed\n     * and destroyed.\n     */\n  constructor (peerId, socket, timeout) {\n    this.peer = peerId // key\n    this.socket = socket\n    this.timeout = timeout\n  };\n};\n\nmodule.exports = EDying\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/entries/edying.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "class",
    "name": "EDying",
    "memberof": "lib/entries/edying.js",
    "static": true,
    "longname": "lib/entries/edying.js~EDying",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/entries/edying.js",
    "importStyle": "EDying",
    "description": "Entry of the dying table containing sockets being removed.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 60,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/entries/edying.js~EDying",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/entries/edying.js~EDying#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\nsocket."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "socket",
        "description": "The WebRTC socket."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time before the connexion is completely removed\nand destroyed."
      }
    ]
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/entries/edying.js~EDying",
    "static": false,
    "longname": "lib/entries/edying.js~EDying#peer",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "socket",
    "memberof": "lib/entries/edying.js~EDying",
    "static": false,
    "longname": "lib/entries/edying.js~EDying#socket",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "timeout",
    "memberof": "lib/entries/edying.js~EDying",
    "static": false,
    "longname": "lib/entries/edying.js~EDying#timeout",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "lib/entries/eliving.js",
    "content": "'use strict'\n\n/**\n * Entry of the living table containing sockets still in use.\n */\nclass ELiving {\n  /**\n     * @param {string} peerId The identifier of the peer reachable through the\n     * socket.\n     * @param {object} socket The WebRTC socket.\n     */\n  constructor (peerId, socket) {\n    this.peer = peerId // key\n    this.socket = socket\n    this.counter = 0\n    this.increment()\n  }\n\n  /**\n     * Add an occurrence of the arc to the protocol\n     */\n  increment () {\n    this.counter++\n  }\n\n  /**\n     * Remove an occurrence of the arc to the protocol\n     */\n  decrement () {\n    this.counter--\n  }\n}\n\nmodule.exports = ELiving\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/entries/eliving.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "ELiving",
    "memberof": "lib/entries/eliving.js",
    "static": true,
    "longname": "lib/entries/eliving.js~ELiving",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/entries/eliving.js",
    "importStyle": "ELiving",
    "description": "Entry of the living table containing sockets still in use.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 66,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/entries/eliving.js~ELiving",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\nsocket."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "socket",
        "description": "The WebRTC socket."
      }
    ]
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/entries/eliving.js~ELiving",
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#peer",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "socket",
    "memberof": "lib/entries/eliving.js~ELiving",
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#socket",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "counter",
    "memberof": "lib/entries/eliving.js~ELiving",
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#counter",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "increment",
    "memberof": "lib/entries/eliving.js~ELiving",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#increment",
    "access": "public",
    "description": "Add an occurrence of the arc to the protocol",
    "lineNumber": 22,
    "params": [],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "decrement",
    "memberof": "lib/entries/eliving.js~ELiving",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/entries/eliving.js~ELiving#decrement",
    "access": "public",
    "description": "Remove an occurrence of the arc to the protocol",
    "lineNumber": 29,
    "params": [],
    "return": null
  },
  {
    "__docId__": 72,
    "kind": "file",
    "name": "lib/entries/epending.js",
    "content": "'use strict'\n\n/**\n * Entry of the pending table containing sockets being created.\n */\nclass EPending {\n  /**\n     * @param {string} temporaryId A temporary id used to retrieve the entry.\n     * @param {string} peerId The identifier of the peer reachable through the\n     * socket. Null if the peerId is yet to be known.\n     * @param {string} protocolId The identifier of the protocol that wishes to\n     * establish the connexion.\n     * @param {object} socket The WebRTC socket.\n     * @param {number} timeout Maximum time for a connexion to establish.\n     */\n  constructor (temporaryId, peerId, socket, timeout) {\n    this.tid = temporaryId // key\n    this.peer = peerId\n    this.socket = socket\n    this.successful = false\n    this.alreadyExists = false\n    this.timeout = timeout\n  };\n};\n\nmodule.exports = EPending\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/entries/epending.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 73,
    "kind": "class",
    "name": "EPending",
    "memberof": "lib/entries/epending.js",
    "static": true,
    "longname": "lib/entries/epending.js~EPending",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/entries/epending.js",
    "importStyle": "EPending",
    "description": "Entry of the pending table containing sockets being created.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 74,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/entries/epending.js~EPending",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/entries/epending.js~EPending#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "temporaryId",
        "description": "A temporary id used to retrieve the entry."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\nsocket. Null if the peerId is yet to be known."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "protocolId",
        "description": "The identifier of the protocol that wishes to\nestablish the connexion."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "socket",
        "description": "The WebRTC socket."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Maximum time for a connexion to establish."
      }
    ]
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "tid",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#tid",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#peer",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "socket",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#socket",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "successful",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#successful",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "alreadyExists",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#alreadyExists",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "timeout",
    "memberof": "lib/entries/epending.js~EPending",
    "static": false,
    "longname": "lib/entries/epending.js~EPending#timeout",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "file",
    "name": "lib/exceptions/exincompletemessage.js",
    "content": "'use strict'\n\n/**\n * Exception thrown when the message does not have the required data.\n */\nclass ExIncompleteMessage {\n  /**\n     * @param {string} source The name of the function that threw the exception.\n     * @param {EPending|ELiving|EDying} entry The entry that requested more\n     * information.\n     * @param {MResponse} message The message lacking data.\n     */\n  constructor (source, entry, message) {\n    this.source = source\n    this.entry = entry\n    this.message = message\n  }\n};\n\nmodule.exports = ExIncompleteMessage\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/exceptions/exincompletemessage.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 82,
    "kind": "class",
    "name": "ExIncompleteMessage",
    "memberof": "lib/exceptions/exincompletemessage.js",
    "static": true,
    "longname": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/exceptions/exincompletemessage.js",
    "importStyle": "ExIncompleteMessage",
    "description": "Exception thrown when the message does not have the required data.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 83,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The name of the function that threw the exception."
      },
      {
        "nullable": null,
        "types": [
          "EPending",
          "ELiving",
          "EDying"
        ],
        "spread": false,
        "optional": false,
        "name": "entry",
        "description": "The entry that requested more\ninformation."
      },
      {
        "nullable": null,
        "types": [
          "MResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message lacking data."
      }
    ]
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "source",
    "memberof": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage",
    "static": false,
    "longname": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage#source",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "entry",
    "memberof": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage",
    "static": false,
    "longname": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage#entry",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "message",
    "memberof": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage",
    "static": false,
    "longname": "lib/exceptions/exincompletemessage.js~ExIncompleteMessage#message",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "lib/exceptions/exlatemessage.js",
    "content": "'use strict'\n\n/**\n * Exception that fires when a message arrives too late and the entry in the\n * table has already been purged.\n */\nclass ExLateMessage {\n  /**\n     * @param {string} source The function name that throw the exception.\n     * @param {object} message The late message\n     */\n  constructor (source, msg) {\n    this.source = source\n    this.msg = msg\n    this.message = 'The message arrives too late'\n  };\n};\n\nmodule.exports = ExLateMessage\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/exceptions/exlatemessage.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "class",
    "name": "ExLateMessage",
    "memberof": "lib/exceptions/exlatemessage.js",
    "static": true,
    "longname": "lib/exceptions/exlatemessage.js~ExLateMessage",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/exceptions/exlatemessage.js",
    "importStyle": "ExLateMessage",
    "description": "Exception that fires when a message arrives too late and the entry in the\ntable has already been purged.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 89,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/exceptions/exlatemessage.js~ExLateMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/exceptions/exlatemessage.js~ExLateMessage#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The function name that throw the exception."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The late message"
      }
    ]
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "source",
    "memberof": "lib/exceptions/exlatemessage.js~ExLateMessage",
    "static": false,
    "longname": "lib/exceptions/exlatemessage.js~ExLateMessage#source",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "msg",
    "memberof": "lib/exceptions/exlatemessage.js~ExLateMessage",
    "static": false,
    "longname": "lib/exceptions/exlatemessage.js~ExLateMessage#msg",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "message",
    "memberof": "lib/exceptions/exlatemessage.js~ExLateMessage",
    "static": false,
    "longname": "lib/exceptions/exlatemessage.js~ExLateMessage#message",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "lib/exceptions/exprotocolexists.js",
    "content": "'use strict'\n\n/**\n * Exception that rise when a protocol registers and its identifier already\n * exists in registered protocols of neighborhood-wrtc.\n */\nclass ExProtocolExists {\n  constructor () {\n    this.message = 'The idenfifier of the registering protocol already exists.'\n  };\n};\n\nmodule.exports = ExProtocolExists\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/exceptions/exprotocolexists.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "ExProtocolExists",
    "memberof": "lib/exceptions/exprotocolexists.js",
    "static": true,
    "longname": "lib/exceptions/exprotocolexists.js~ExProtocolExists",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/exceptions/exprotocolexists.js",
    "importStyle": "ExProtocolExists",
    "description": "Exception that rise when a protocol registers and its identifier already\nexists in registered protocols of neighborhood-wrtc.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/exceptions/exprotocolexists.js~ExProtocolExists",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/exceptions/exprotocolexists.js~ExProtocolExists#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "message",
    "memberof": "lib/exceptions/exprotocolexists.js~ExProtocolExists",
    "static": false,
    "longname": "lib/exceptions/exprotocolexists.js~ExProtocolExists#message",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "lib/exceptions/exsocketnotfound.js",
    "content": "'use strict'\n\n/**\n * Exception that fires when trying to access or use a socket that does not\n * exist.\n */\nclass ExSocketNotFound {\n  /**\n     * @param {string} source The source of the exception.\n     * @param {string} peerId The identifier of the peer that has been tried.\n     * @param {string} message A error message.\n     */\n  constructor (source, peerId, message) {\n    this.source = source\n    this.peer = peerId\n    this.message = message\n  };\n};\n\nmodule.exports = ExSocketNotFound\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/exceptions/exsocketnotfound.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 98,
    "kind": "class",
    "name": "ExSocketNotFound",
    "memberof": "lib/exceptions/exsocketnotfound.js",
    "static": true,
    "longname": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/exceptions/exsocketnotfound.js",
    "importStyle": "ExSocketNotFound",
    "description": "Exception that fires when trying to access or use a socket that does not\nexist.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 99,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The source of the exception."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer that has been tried."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "A error message."
      }
    ]
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "source",
    "memberof": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound",
    "static": false,
    "longname": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound#source",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound",
    "static": false,
    "longname": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound#peer",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "message",
    "memberof": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound",
    "static": false,
    "longname": "lib/exceptions/exsocketnotfound.js~ExSocketNotFound#message",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "file",
    "name": "lib/exceptions/exundefinedfunction.js",
    "content": "'use strict'\n\n/**\n * Exception that fires when the interface of the protocol using neighborhood is\n * not complete.\n */\nclass ExUndefinedFunction {\n  /**\n     * @param {string} source The function name that is not provided.\n     */\n  constructor (source) {\n    this.source = source\n    this.message = 'The function was not provided.'\n  };\n}\n\nmodule.exports = ExUndefinedFunction\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/exceptions/exundefinedfunction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 104,
    "kind": "class",
    "name": "ExUndefinedFunction",
    "memberof": "lib/exceptions/exundefinedfunction.js",
    "static": true,
    "longname": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/exceptions/exundefinedfunction.js",
    "importStyle": "ExUndefinedFunction",
    "description": "Exception that fires when the interface of the protocol using neighborhood is\nnot complete.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 105,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The function name that is not provided."
      }
    ]
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "source",
    "memberof": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction",
    "static": false,
    "longname": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction#source",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "message",
    "memberof": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction",
    "static": false,
    "longname": "lib/exceptions/exundefinedfunction.js~ExUndefinedFunction#message",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "lib/iprotocol.js",
    "content": "'use strict'\n\nconst N = require('./neighborhood')\n/**\n * An interface for protocols that checks if all functions have been provided.\n * Not fully necessary since it will only be checked at runtime anyway.\n */\nclass IProtocol extends N {\n  /**\n     * Behavior when an arc leading to peer has been established.\n     * @param {string} [peerId] The identifier of the peer reachable through the\n     * arc.\n     * @param {boolean} [isOutgoing] State whether or not the added arc is an\n     * outgoing arc.\n     */\n  _connected (peerId, isOutgoing) { throw new Error('[_connected] not yet implemented.') }\n\n  /**\n     * Behavior when an arc leading to peer has been disconnected.\n     * @param {string} [peerId] The identifier of the peer reachable through the\n     * arc.\n     */\n  _disconnected (peerId) { throw new Error('[_disconnected] not yet implemented.') }\n\n  /**\n     * Behavior when an arc failed to establish properly.\n     * @param {string} [peerId] The identifier of the peer that we tried to\n     * establish a connection with.\n     * @param {boolean} [isOutgoing] State whether or not the failed arc was\n     * supposed to be an outgoing arc.\n     */\n  _failed (peerId, isOutgoing) { throw new Error('[_failed] not yet implemented.') }\n\n  /**\n     * Behavior when a message from peerId has been received.\n     * @param {string} [peerId] The identifier of the peer that sent the message.\n     * @param {object} [message] The received message.\n     */\n  _received (peerId, message) { throw new Error('[_received] not yet implemented.') }\n\n  /**\n     * Behavior when a stream from peerId is being received.\n     * @param {string} [peerId] The identifier of the peer that sent the message.\n     * @param {object} [stream] The received stream.\n     */\n  _streamed (peerId, stream) { throw new Error('[_streamed] not yet implemented.') }\n}\n\nmodule.exports = IProtocol\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/iprotocol.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "class",
    "name": "IProtocol",
    "memberof": "lib/iprotocol.js",
    "static": true,
    "longname": "lib/iprotocol.js~IProtocol",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc",
    "importStyle": "IProtocol",
    "description": "An interface for protocols that checks if all functions have been provided.\nNot fully necessary since it will only be checked at runtime anyway.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "lib/neighborhood.js~N"
    ]
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "_connected",
    "memberof": "lib/iprotocol.js~IProtocol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/iprotocol.js~IProtocol#_connected",
    "access": "private",
    "description": "Behavior when an arc leading to peer has been established.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\narc."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "isOutgoing",
        "description": "State whether or not the added arc is an\noutgoing arc."
      }
    ],
    "return": null
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "_disconnected",
    "memberof": "lib/iprotocol.js~IProtocol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/iprotocol.js~IProtocol#_disconnected",
    "access": "private",
    "description": "Behavior when an arc leading to peer has been disconnected.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "peerId",
        "description": "The identifier of the peer reachable through the\narc."
      }
    ],
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "_failed",
    "memberof": "lib/iprotocol.js~IProtocol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/iprotocol.js~IProtocol#_failed",
    "access": "private",
    "description": "Behavior when an arc failed to establish properly.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "peerId",
        "description": "The identifier of the peer that we tried to\nestablish a connection with."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "isOutgoing",
        "description": "State whether or not the failed arc was\nsupposed to be an outgoing arc."
      }
    ],
    "return": null
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "_received",
    "memberof": "lib/iprotocol.js~IProtocol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/iprotocol.js~IProtocol#_received",
    "access": "private",
    "description": "Behavior when a message from peerId has been received.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "peerId",
        "description": "The identifier of the peer that sent the message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "message",
        "description": "The received message."
      }
    ],
    "return": null
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "_streamed",
    "memberof": "lib/iprotocol.js~IProtocol",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/iprotocol.js~IProtocol#_streamed",
    "access": "private",
    "description": "Behavior when a stream from peerId is being received.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "peerId",
        "description": "The identifier of the peer that sent the message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "stream",
        "description": "The received stream."
      }
    ],
    "return": null
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "lib/messages/minternalsend.js",
    "content": "'use strict'\n\n/**\n * Message sent.\n */\nclass MInternalSend {\n  /**\n     * @param {string} peerId The identifier of the peer that sent the message\n     * @param {object} payload The payload of the message.\n     */\n  constructor (peerId, payload) {\n    this.peer = peerId\n    this.payload = payload\n    this.type = 'MInternalSend'\n  }\n}\n\nmodule.exports = MInternalSend\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/messages/minternalsend.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "class",
    "name": "MInternalSend",
    "memberof": "lib/messages/minternalsend.js",
    "static": true,
    "longname": "lib/messages/minternalsend.js~MInternalSend",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/messages/minternalsend.js",
    "importStyle": "MInternalSend",
    "description": "Message sent.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 117,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/messages/minternalsend.js~MInternalSend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/messages/minternalsend.js~MInternalSend#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer that sent the message"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "The payload of the message."
      }
    ]
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/messages/minternalsend.js~MInternalSend",
    "static": false,
    "longname": "lib/messages/minternalsend.js~MInternalSend#peer",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "payload",
    "memberof": "lib/messages/minternalsend.js~MInternalSend",
    "static": false,
    "longname": "lib/messages/minternalsend.js~MInternalSend#payload",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "type",
    "memberof": "lib/messages/minternalsend.js~MInternalSend",
    "static": false,
    "longname": "lib/messages/minternalsend.js~MInternalSend#type",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "file",
    "name": "lib/messages/mrequest.js",
    "content": "'use strict'\n\n/**\n * The message containing the request to create a WebRTC connexion\n */\nclass MRequest {\n  /**\n     * @param {string} temporaryId A temporary identifier during the socket\n     * creation. The key will be changed to peerId when the connexion is\n     * established successfully.\n     * @param {string} peerId The identifier of the peer that will be reachable\n     * through the socket being created. Null if it is yet to be known.\n     * @param {object} offer The WebRTC offer containing ways to establish a\n     * direct peer-to-peer connexions. See WebRTC for more information.\n     */\n  constructor (temporaryId, peerId, offer, offerType = 'init') {\n    this.tid = temporaryId\n    this.peer = peerId\n    this.offer = offer\n    this.type = 'MRequest'\n    this.offerType = offerType\n  }\n}\n\nmodule.exports = MRequest\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/messages/mrequest.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "MRequest",
    "memberof": "lib/messages/mrequest.js",
    "static": true,
    "longname": "lib/messages/mrequest.js~MRequest",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/messages/mrequest.js",
    "importStyle": "MRequest",
    "description": "The message containing the request to create a WebRTC connexion",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "temporaryId",
        "description": "A temporary identifier during the socket\ncreation. The key will be changed to peerId when the connexion is\nestablished successfully."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer that will be reachable\nthrough the socket being created. Null if it is yet to be known."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "offer",
        "description": "The WebRTC offer containing ways to establish a\ndirect peer-to-peer connexions. See WebRTC for more information."
      }
    ]
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "tid",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#tid",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#peer",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "offer",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#offer",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "type",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#type",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "offerType",
    "memberof": "lib/messages/mrequest.js~MRequest",
    "static": false,
    "longname": "lib/messages/mrequest.js~MRequest#offerType",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "file",
    "name": "lib/messages/mresponse.js",
    "content": "'use strict'\n\n/**\n * The message containing the response to create a WebRTC connexion\n */\nclass MResponse {\n  /**\n     * @param {string} temporaryId A temporary identifier during the socket\n     * creation. The key will be changed to peerId when the connexion is established\n     * successfully.\n     * @param {string} peerId The identifier of the peer that will be reachable\n     * through the socket being created. Null if it is yet to be known.\n     * @param {object} offer The WebRTC offer containing ways to establish a direct\n     * peer-to-peer connexions. See WebRTC for more information.\n     */\n  constructor (temporaryId, peerId, offer, offerType = 'init') {\n    this.tid = temporaryId\n    this.peer = peerId\n    this.offer = offer\n    this.type = 'MResponse'\n    this.offerType = offerType\n  }\n}\n\nmodule.exports = MResponse\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/messages/mresponse.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 130,
    "kind": "class",
    "name": "MResponse",
    "memberof": "lib/messages/mresponse.js",
    "static": true,
    "longname": "lib/messages/mresponse.js~MResponse",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/messages/mresponse.js",
    "importStyle": "MResponse",
    "description": "The message containing the response to create a WebRTC connexion",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 131,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "temporaryId",
        "description": "A temporary identifier during the socket\ncreation. The key will be changed to peerId when the connexion is established\nsuccessfully."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer that will be reachable\nthrough the socket being created. Null if it is yet to be known."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "offer",
        "description": "The WebRTC offer containing ways to establish a direct\npeer-to-peer connexions. See WebRTC for more information."
      }
    ]
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "tid",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#tid",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#peer",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "offer",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#offer",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "type",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#type",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "offerType",
    "memberof": "lib/messages/mresponse.js~MResponse",
    "static": false,
    "longname": "lib/messages/mresponse.js~MResponse#offerType",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "file",
    "name": "lib/messages/msend.js",
    "content": "'use strict'\n\n/**\n * Message sent when protocolId wishes to send payload. It is a basic\n * encapsualtion of protocolId.\n */\nclass MSend {\n  /**\n     * @param {string} peerId The identifier of the peer that sent the message\n     * @param {string} protocolId The identifier of the protocol that sent the\n     * message\n     * @param {object} payload The payload of the message.\n     */\n  constructor (peerId, payload) {\n    this.peer = peerId\n    this.payload = payload\n    this.type = 'MSend'\n  };\n};\n\nmodule.exports = MSend\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/messages/msend.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "MSend",
    "memberof": "lib/messages/msend.js",
    "static": true,
    "longname": "lib/messages/msend.js~MSend",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/messages/msend.js",
    "importStyle": "MSend",
    "description": "Message sent when protocolId wishes to send payload. It is a basic\nencapsualtion of protocolId.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/messages/msend.js~MSend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/messages/msend.js~MSend#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer that sent the message"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "protocolId",
        "description": "The identifier of the protocol that sent the\nmessage"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "The payload of the message."
      }
    ]
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "peer",
    "memberof": "lib/messages/msend.js~MSend",
    "static": false,
    "longname": "lib/messages/msend.js~MSend#peer",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "payload",
    "memberof": "lib/messages/msend.js~MSend",
    "static": false,
    "longname": "lib/messages/msend.js~MSend#payload",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "type",
    "memberof": "lib/messages/msend.js~MSend",
    "static": false,
    "longname": "lib/messages/msend.js~MSend#type",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "file",
    "name": "lib/neighborhood.js",
    "content": "'use strict'\n\nconst debug = (require('debug'))('neighborhood-wrtc')\n\nconst merge = require('lodash.merge')\nconst uuid = require('uuid/v4')\nconst Socket = require('simple-peer')\nconst Events = require('events')\n\nconst ArcStore = require('./arcstore.js')\nconst EPending = require('./entries/epending.js')\nconst EDying = require('./entries/edying.js')\n\nconst MResponse = require('./messages/mresponse.js')\nconst MRequest = require('./messages/mrequest.js')\nconst MSend = require('./messages/msend.js')\nconst MInternalSend = require('./messages/minternalsend.js')\n\nconst ExIncompleteMessage = require('./exceptions/exincompletemessage.js')\n\n/**\n * Easy-to-use interface to establish multiple WebRTC connections using\n * SimplePeer (npm: simple-peer)\n */\nclass Neighborhood extends Events {\n  /**\n     * @param {object} [options] the options available to the connections, e.g.\n     * timeout before\n     * @param {object} [options.socketClass] simple-peer default socket class (usefull if you need to change the type of socket)\n     * @param {object} [options.config] simple-peer options\n     * @param {number} [options.timeout = 60000] Time to wait (in milliseconds) for dying socket\n     * @param {number} [options.pendingTimeout = 10000] Time to wait (in milliseconds) for pending socket\n     * before neighborhood-wrtc assumes that a connection establishment failed,\n     * or before an unused connection is removed.\n     * @param {function} [options.encoding] Method to customize message sent,\n     * default: return JSON.stringify(data);\n     * @param {function} [options.decoding] Method to decode a received message,\n     * default: return JSON.parse(data);\n     */\n  constructor (options) {\n    super()\n    // #1 save options\n    this.options = {\n      socketClass: Socket,\n      peer: uuid(),\n      config: { trickle: true, initiator: false },\n      timeout: 1 * 60 * 1000,\n      pendingTimeout: 10 * 1000,\n      encoding: (d) => { return JSON.stringify(d) },\n      decoding: (d) => { return JSON.parse(d) }\n    }\n    this.options = merge(this.options, options)\n    this.encode = this.options.encoding // not sure it should stay that\n    this.decode = this.options.decoding // way\n\n    // #2 unmutable values\n    this.PEER = this.options.peer\n    debug('[%s] initialized.', this.PEER)\n\n    // #3 initialize tables\n    this.pending = new Map() // not finalized yet\n    this.living = new ArcStore() // live and usable\n    this.dying = new Map() // being removed\n  }\n\n  /**\n   * Create a WebRTC connection.\n   * @param {function|object} arg1 Either a callback function to send the\n   * message to the remote peer (for instance, it can use a signaling server\n   * or the already created WebRTC connexions), or a message received from the\n   * remote peer.\n   * @param {object} arg2 The message received from a peer that initialized a\n   * WebRTC connection.\n   */\n  connect (arg1, arg2) {\n    return new Promise((resolve, reject) => {\n      const id = uuid()\n      if (typeof arg1 === 'function' && typeof arg2 === 'undefined') {\n        this._initiate(arg1, id) // arg1: callback for offers\n      } else if (typeof arg1 === 'function' && typeof arg2 !== 'undefined') {\n        this._accept(arg1, arg2, id) // arg1:callback, arg2:request\n      } else {\n        this._finalize(arg1, id) // arg1: response\n      }\n      this.once(id, (connectedWith, timeout = false) => {\n        if (timeout) reject(new Error('timeout exceeded.'))\n        resolve(connectedWith)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * Initiate the creation of a WebRTC connection. At this point, the identity\n   * of the remote peer is unknown.\n   * @param {function} sender A function called at each offer\n   * @param {String} jobId The jobId that initiate the connection\n   */\n  _initiate (sender, jobId) {\n    // #1 create an initiator\n    this.options.config.initiator = true\n    let SocketClass = this.options.socketClass\n    let socket = new SocketClass(this.options.config)\n    // #2 insert the new entry in the pending table\n    let entry = new EPending(uuid(), null, socket)\n    entry.jobId = jobId\n    // entry.tid = peerIdToConnectWith || entry.tid\n    this.pending.set(entry.tid, entry)\n\n    // #3 define events\n    socket.once('connect', () => {\n      entry.successful = true\n      if (this.living.contains(entry.peer)) {\n        entry.alreadyExists = true\n        entry.successful = true\n        this.living.insert(entry.peer)\n        debug('[%s] --- arc --> %s', this.PEER, entry.peer)\n        debug('[init] emit connect event: ', entry.jobId, entry.peer, false, entry)\n        this.emit(entry.jobId, entry.peer, false)\n        // notify\n        this._connected(entry.peer, true)\n        entry.peer = null // becomes the unknown soldier\n      } else {\n        this.living.insert(entry.peer, socket)\n        debug('[%s] --- WebRTC --> %s', this.PEER, entry.peer)\n        debug('[init] emit connect event: ', entry.jobId, entry.peer, false, entry)\n        this.emit(entry.jobId, entry.peer, false)\n        // notify\n        this._connected(entry.peer, true)\n      }\n\n      this._checkPendingEntry(entry)\n    })\n    socket.once('close', () => {\n      if (entry.peer !== null) { // if not the unknown soldier\n        if (this.living.contains(entry.peer)) {\n          // #A remove the socket from the table of living connections\n          this.living.removePeer(entry.peer)\n          // #B notify\n          this._disconnected(entry.peer)\n        } else if (this.dying.has(entry.peer)) {\n          let d = this.dying.get(entry.peer)\n          clearTimeout(d.timeout)\n          this.dying.delete(entry.peer)\n        }\n        debug('[%s] -‡- WebRTC -‡> %s', this.PEER, entry.peer)\n        debug('[init] emit close event: ', entry.jobId, entry.peer, true)\n        this._checkPendingEntry(entry)\n        this.emit(entry.jobId, entry.peer, true)\n      } else {\n        debug('[%s] -‡- WebRTC -‡> %s', this.PEER, 'unknown')\n      }\n    })\n\n    socket.on('data', (d) => {\n      let msg = this.decode(d)\n      if (msg.type === 'MInternalSend') {\n        this._receiveInternalMessage(msg)\n      } else {\n        this._received(msg.peer, msg.payload)\n      }\n    })\n    socket.on('stream', (s) => {\n      this._streamed(entry.peer, s)\n    })\n    socket.on('error', (e) => {\n      // Nothing here, for the failure are detected and handled after\n      // this.options.timeout milliseconds.\n      debug(e)\n      socket.destroy()\n      debug('[init] emit error event: ', entry.jobId, entry.peer, true)\n      this.emit(entry.jobId, entry.peer, true)\n    })\n    // #4 send offer message using sender\n    socket.on('signal', (offer) => {\n      if (socket.connected && !socket._isNegociating) {\n        this._sendRenegociateRequest(new MRequest(entry.tid, this.PEER, offer, 'renegociate'), entry.peer)\n      } else {\n        sender(new MRequest(entry.tid, this.PEER, offer))\n      }\n    })\n\n    // #5 check if the socket has been established correctly\n    setTimeout(() => {\n      if ((!entry.successful || entry.alreadyExists) && (entry.socket !== null)) {\n        entry.socket.destroy()\n      }\n      if (!entry.successful) {\n        this._failed(entry.peer, true)\n        debug('[init] emit timeout event: ', entry.jobId, entry.peer, true)\n        this.emit(entry.jobId, entry.peer, true)\n      }\n      this.pending.delete(entry.tid)\n    }, this.options.pendingTimeout)\n  }\n\n  /**\n     * @private\n     * Try to finalize the WebRTC connection using the remote offers.\n     * @param {MResponse} msg The message containing an offer, a peerId etc.\n     */\n  _finalize (msg) {\n    if (msg.offerType === 'renegociate') {\n      debug(`[%s] _finalize regenociation:`, msg)\n      if (this.living.store.has(msg.peer)) {\n        const socket = this.living.get(msg.peer).socket\n        socket.connected && !socket._isNegociating && socket.signal(msg.offer)\n      }\n      return\n    }\n    if (!this.pending.has(msg.tid)) {\n      // debug(new ExLateMessage('_finalize', msg))\n      return\n    }\n\n    let entry = this.pending.get(msg.tid)\n    if (entry) {\n      if (entry.alreadyExists || entry.successful) {\n        this._checkPendingEntry(entry)\n        debug('The socket already exists: ', entry.peer)\n        return\n      }\n    }\n    debug('[finalize]', entry)\n    // #A check if the connection already exists\n    if (this.living.contains(msg.peer)) {\n      entry.alreadyExists = true\n      entry.successful = true\n      this.living.insert(msg.peer)\n\n      debug('[%s]finalize --- arc --> %s', this.PEER, msg.peer)\n      this._connected(msg.peer, true)\n      this.emit(entry.jobId, msg.peer, false)\n\n      this._checkPendingEntry(entry)\n    } else if (this.dying.has(msg.peer)) {\n      // #B rise from the dead\n      entry.alreadyExists = true\n      entry.successful = true\n      let rise = this.dying.get(msg.peer)\n      clearTimeout(rise.timeout)\n      this.dying.delete(msg.peer)\n      this.living.insert(msg.peer, rise.socket)\n\n      debug('[%s]finalize -¡- arc -¡> %s', this.PEER, msg.peer)\n      this._connected(msg.peer, true)\n      this.emit(entry.jobId, msg.peer, false)\n\n      this._checkPendingEntry(entry)\n    } else {\n      // #C just signal the offer\n      entry.peer = msg.peer\n      if (!msg.offer) {\n        throw new ExIncompleteMessage('_finalize', entry, msg)\n      } else {\n        debug('[finalize] signaling: ', msg)\n        entry.socket.signal(msg.offer)\n      }\n    }\n  }\n\n  /**\n     * @private\n     * Establish a connection in response to the request of remote peer.\n     * @param {function} sender The function that send the offer to the remote\n     * initiating peer.\n     * @param {MRequest} msg The request message containing offers, peerId, etc.\n     **/\n  _accept (sender, msg) {\n    if (msg.offerType === 'renegociate') {\n      debug(`[%s] _accept regenociation:`, msg)\n      if (this.living.store.has(msg.peer)) {\n        this.living.get(msg.peer).socket.signal(msg.offer)\n      }\n      return\n    }\n    // #1 initialize the entry if it does not exist\n    let firstCall = false\n    const tid = msg.tid\n    const peer = msg.peer\n    if (!this.pending.has(tid)) {\n      firstCall = true\n      let entry = new EPending(tid, peer)\n      this.pending.set(tid, entry)\n\n      setTimeout(() => {\n        (!entry.successful || entry.alreadyExists) && entry.socket && entry.socket.destroy()\n        !entry.successful && this._failed(peer, false)\n        this.pending.delete(tid)\n      }, this.options.pendingTimeout)\n    }\n\n    // #2 check if a WebRTC connection to peerId already exists\n    let entry = this.pending.get(msg.tid)\n    // let entry = this.pending.get(peer)\n    if (entry.alreadyExists || entry.successful) { return }\n\n    // #A check if the connection already exists\n    if (this.living.contains(msg.peer)) {\n      entry.alreadyExists = true\n      entry.successful = true\n      this.living.insert(msg.peer)\n      debug('[%s] <-- arc --- %s', this.PEER, entry.peer)\n      this._connected(msg.peer, false)\n      firstCall && sender(new MResponse(entry.tid, this.PEER, null))\n\n      this._checkPendingEntry(entry)\n    } else if (this.dying.has(msg.peer)) {\n      // #B rise from the dead\n      entry.alreadyExists = true\n      entry.successful = true\n      let rise = this.dying.get(msg.peer)\n      clearTimeout(rise.timeout)\n      this.dying.delete(msg.peer)\n      this.living.insert(msg.peer, rise.socket)\n      debug('[%s] <¡- arc -¡- %s', this.PEER, msg.peer)\n      this._connected(msg.peer, false)\n      firstCall && sender(new MResponse(entry.tid, this.PEER, null))\n\n      // delete the pending entry cause we do not use the created one if exists\n      this._checkPendingEntry(entry)\n    } else {\n      // #3 create the events and signal the offer\n      if (firstCall && !entry.socket) {\n        // #A create a socket\n        this.options.config.initiator = false\n        let SocketClass = this.options.socketClass\n        let socket = new SocketClass(this.options.config)\n        // #B update the entry\n        entry.socket = socket\n        // #C define events\n        socket.once('connect', () => {\n          entry.successful = true\n          if (this.living.contains(entry.peer)) {\n            entry.alreadyExists = true\n            entry.successful = true\n            this.living.insert(entry.peer)\n            debug('[%s] <-- arc --- %s', this.PEER, entry.peer)\n            this._connected(entry.peer,\n              false)\n            entry.peer = null // becomes the unknown soldier\n          } else {\n            this.living.insert(entry.peer, socket)\n            debug('[%s] <-- WebRTC --- %s', this.PEER, entry.peer)\n            this._connected(entry.peer,\n              false)\n          }\n\n          this._checkPendingEntry(entry)\n        })\n        socket.once('close', () => {\n          if (entry.peer !== null) { // if not the unknown soldier\n            if (this.living.contains(entry.peer)) {\n              // #A remove the socket from the table of\n              // living connections\n              this.living.removePeer(entry.peer)\n              this._disconnected(entry.peer)\n            } else if (this.dying.has(entry.peer)) {\n              let d = this.dying.get(entry.peer)\n              clearTimeout(d.timeout)\n              this.dying.delete(entry.peer)\n            }\n            debug('[%s] <‡- WebRTC -‡- %s', this.PEER, entry.peer)\n          } else {\n            debug('[%s] <‡- WebRTC -‡- %s', this.PEER, 'unknown')\n          }\n          this._checkPendingEntry(entry)\n        })\n\n        socket.on('data', (d) => {\n          let msg = this.decode(d)\n          if (msg.type === 'MInternalSend') {\n            this._receiveInternalMessage(msg)\n          } else {\n            this._received(msg.peer, msg.payload)\n          }\n        })\n        socket.on('stream', (s) => {\n          this._streamed(entry.peer, s)\n        })\n        socket.on('error', (e) => {\n          // Nothing here, for the failure are detected and handled\n          // after this.options.timeout milliseconds.\n          debug(e)\n          socket.destroy()\n        })\n        // #4 send offer message using sender\n        socket.on('signal', (offer) => {\n          if (socket.connected && !socket._isNegotiating) {\n            this._sendRenegociateResponse(new MResponse(entry.tid, this.PEER, offer, 'renegociate'), entry.peer)\n          } else {\n            sender(new MResponse(entry.tid, this.PEER, offer))\n          }\n        })\n      }\n      entry.socket.signal(msg.offer)\n    }\n  }\n\n  /**\n     * Remove an arc. If it was the last arc,\n     * the WebRTC connexion is downgraded to the dying table. In this table, the\n     * connexion will be closed if none create it.\n     * @param {string|undefined} peerId The identifier of the peer. If no arg,\n     * remove all arcs.\n     */\n  disconnect (peerId) {\n    return new Promise((resolve, reject) => {\n      if (typeof peerId === 'undefined') {\n        // #1 remove all arcs\n        let entries\n        try {\n          entries = this.living.removeAll()\n        } catch (e) {\n          return reject(e)\n        }\n        entries.forEach((entry) => {\n          if (entry.socket !== null) {\n            let dying = new EDying(entry.peer, entry.socket,\n              setTimeout(() => {\n                entry.socket && entry.socket.destroy()\n              }, this.options.timeout))\n            this.dying.set(dying.peer, dying)\n          }\n\n          for (let i = 0; i < entry.occ; ++i) {\n            if (entry.socket === null || (entry.socket !== null && i < entry.occ - 1)) {\n              debug('DISCONNECT-ALL [%s] ††† arc ††† %s', this.PEER, peerId)\n            } else {\n              debug('DISCONNECT-ALL [%s] ††† WebRTC ††† %s', this.PEER, peerId)\n            }\n            this._disconnected(entry.peer)\n          }\n          resolve()\n        })\n      } else {\n        let entry = null\n        // #2 remove one arc\n        try {\n          entry = this.living.remove(peerId)\n        } catch (e) {\n          return reject(e)\n        }\n        if (entry) {\n          let dying = new EDying(entry.peer, entry.socket, setTimeout(() => {\n            entry.socket && entry.socket.destroy()\n          }, this.options.timeout))\n          this.dying.set(dying.peer, dying)\n          debug('DISCONNECT-ONE [%s] ††† WebRTC ††† %s', this.PEER, peerId)\n        } else {\n          debug('DISCONNECT-ONE [%s] ††† arc ††† %s', this.PEER, peerId)\n        }\n        this._disconnected(peerId)\n        resolve()\n      }\n    })\n  }\n\n  /**\n     * Send a message to a remote peer.\n     * @param {string} peerId The remote peer to send the message to.\n     * @param {object} message The message to send.\n     * @param {number} [retry=0] Retry few times to send the message before\n     * giving up.\n     * @returns {promise} Resolved when the message is sent, reject\n     * otherwise. Note that loss of messages is not handled by default.\n     */\n  send (peerId, message, retry = 0) {\n    return new Promise((resolve, reject) => {\n      // #1 get the proper entry in the tables\n      let entry = null\n      if (this.living.contains(peerId)) {\n        entry = this.living.get(peerId)\n      } else if (this.dying.has(peerId)) {\n        entry = this.dying.get(peerId) // (TODO) warn: not safe\n      }\n      if (entry === null) {\n        return reject(new Error('peer not found: ' + peerId))\n      }\n      // #2 define the recursive sending function\n      let __send = (r) => {\n        try {\n          entry.socket.send(this.encode(new MSend(this.PEER, message)))\n          debug('[%s] --- msg --> %s:%s', this.PEER, peerId)\n          resolve()\n        } catch (e) {\n          debug('[%s] -X- msg -X> %s:%s', this.PEER, peerId)\n          if (r < retry) {\n            setTimeout(() => { __send(r + 1) }, 1000)\n          } else {\n            return reject(e)\n          }\n        }\n      }\n      // #3 start to send\n      __send(0)\n    })\n  }\n\n  stream (peerId, media, retry = 0) {\n    return new Promise((resolve, reject) => {\n      // #1 get the proper entry in the tables\n      let entry = null\n      if (this.living.contains(peerId)) {\n        entry = this.living.get(peerId)\n      } else if (this.dying.has(peerId)) {\n        entry = this.dying.get(peerId) // (TODO) warn: not safe\n      }\n      if (entry === null) {\n        this.living.store.forEach(elem => {\n          debug(elem.peer)\n        })\n        reject(new Error('peer not found: ' + peerId))\n      }\n      // #2 define the recursive sending function\n      let __send = (r) => {\n        try {\n          entry.socket.addStream(media)\n          debug('[%s] --- MEDIA msg --> %s:%s', this.PEER, peerId)\n          resolve()\n        } catch (e) {\n          debug('[%s] -X- MEDIA msg -X> %s:%s', this.PEER, peerId)\n          if (r < retry) {\n            setTimeout(() => { __send(r + 1) }, 1000)\n          } else {\n            reject(e)\n          }\n        }\n      }\n      // #3 start to send\n      __send(0)\n    })\n  }\n\n  _sendRenegociateRequest (request, to, retry = 0) {\n    return new Promise((resolve, reject) => {\n      // #1 get the proper entry in the tables\n      let entry = null\n      if (this.living.contains(to)) {\n        entry = this.living.get(to)\n      } else if (this.dying.has(to)) {\n        entry = this.dying.get(to) // (TODO) warn: not safe\n      }\n      if (entry === null) {\n        this.living.store.forEach(elem => {\n          debug(elem.peer)\n        })\n        return reject(new Error('peer not found: ' + to))\n      }\n      // #2 define the recursive sending function\n      let __send = (r) => {\n        try {\n          entry.socket.send(this.encode(new MInternalSend(this.PEER, request)))\n          debug('[%s] --- MEDIA Internal Renegociate msg --> %s:%s',\n            this.PEER, to)\n          resolve()\n        } catch (e) {\n          debug('[%s] -X- MEDIA Internal Renegociate msg -X> %s:%s',\n            this.PEER, to)\n          if (r < retry) {\n            setTimeout(() => { __send(r + 1) }, 1000)\n          } else {\n            return reject(e)\n          }\n        }\n      }\n      // #3 start to send\n      __send(0)\n    })\n  }\n\n  _sendRenegociateResponse (response, to, retry = 0) {\n    return new Promise((resolve, reject) => {\n      // #1 get the proper entry in the tables\n      let entry = null\n      if (this.living.contains(to)) {\n        entry = this.living.get(to)\n      } else if (this.dying.has(to)) {\n        entry = this.dying.get(to) // (TODO) warn: not safe\n      }\n      if (entry === null) {\n        this.living.store.forEach(elem => {\n          debug(elem.peer)\n        })\n        return reject(new Error('peer not found: ' + to))\n      }\n      // #2 define the recursive sending function\n      let __send = (r) => {\n        try {\n          entry.socket.send(this.encode(new MInternalSend(this.PEER, response)))\n          debug('[%s] --- MEDIA Internal Renegociate msg --> %s:%s',\n            this.PEER, to)\n          resolve()\n        } catch (e) {\n          debug('[%s] -X- MEDIA Internal Renegociate msg -X> %s:%s',\n            this.PEER, to)\n          if (r < retry) {\n            setTimeout(() => { __send(r + 1) }, 1000)\n          } else {\n            return reject(e)\n          }\n        }\n      }\n      // #3 start to send\n      __send(0)\n    })\n  }\n\n  _receiveInternalMessage (msg) {\n    debug('Receive internal message: ', msg)\n    this.living.get(msg.peer).socket.signal(msg.payload.offer)\n  }\n\n  /**\n   * return an array of living sockets\n   * @return {[ELiving]} a living entry with socket, peer id and number of occurences (arcs)\n   */\n  neighbours () {\n    const neigh = []\n    this.living.store.forEach(elem => {\n      neigh.push(elem)\n    })\n    return neigh\n  }\n\n  _checkPendingEntry (entry) {\n    if (this.pending.has(entry.tid)) {\n      if (entry.peer === null) {\n        if (entry.socket) {\n          entry.socket.destroy()\n          entry.socket = null\n        }\n      }\n      this.pending.delete(entry.tid)\n    }\n  }\n}\n\nmodule.exports = Neighborhood\n",
    "static": true,
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/lib/neighborhood.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "debug",
    "memberof": "lib/neighborhood.js",
    "static": true,
    "longname": "lib/neighborhood.js~debug",
    "access": "public",
    "export": false,
    "importPath": "neighborhood-wrtc/lib/neighborhood.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 145,
    "kind": "class",
    "name": "Neighborhood",
    "memberof": "lib/neighborhood.js",
    "static": true,
    "longname": "lib/neighborhood.js~Neighborhood",
    "access": "public",
    "export": true,
    "importPath": "neighborhood-wrtc/lib/neighborhood.js",
    "importStyle": "Neighborhood",
    "description": "Easy-to-use interface to establish multiple WebRTC connections using\nSimplePeer (npm: simple-peer)",
    "lineNumber": 25,
    "interface": false,
    "extends": [
      "events~Events"
    ]
  },
  {
    "__docId__": 146,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "the options available to the connections, e.g.\ntimeout before"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.socketClass",
        "description": "simple-peer default socket class (usefull if you need to change the type of socket)"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.config",
        "description": "simple-peer options"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 60000",
        "defaultRaw": 60000,
        "name": "options.timeout",
        "description": "Time to wait (in milliseconds) for dying socket"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " 10000",
        "defaultRaw": 10000,
        "name": "options.pendingTimeout",
        "description": "Time to wait (in milliseconds) for pending socket\nbefore neighborhood-wrtc assumes that a connection establishment failed,\nor before an unused connection is removed."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.encoding",
        "description": "Method to customize message sent,\ndefault: return JSON.stringify(data);"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.decoding",
        "description": "Method to decode a received message,\ndefault: return JSON.parse(data);"
      }
    ]
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "options",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#options",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "{\"socketClass\": *, \"peer\": *, \"config\": *, \"timeout\": *, \"pendingTimeout\": *, \"encoding\": *, \"decoding\": *}"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "encode",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#encode",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "decode",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#decode",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "PEER",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#PEER",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "pending",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#pending",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "living",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#living",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "dying",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#dying",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "connect",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#connect",
    "access": "public",
    "description": "Create a WebRTC connection.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "function",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg1",
        "description": "Either a callback function to send the\nmessage to the remote peer (for instance, it can use a signaling server\nor the already created WebRTC connexions), or a message received from the\nremote peer."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arg2",
        "description": "The message received from a peer that initialized a\nWebRTC connection."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "_initiate",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_initiate",
    "access": "private",
    "description": "",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "sender",
        "description": "A function called at each offer"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "jobId",
        "description": "The jobId that initiate the connection"
      }
    ],
    "return": null
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "_finalize",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_finalize",
    "access": "private",
    "description": "",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "MResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The message containing an offer, a peerId etc."
      }
    ],
    "return": null
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "_accept",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_accept",
    "access": "private",
    "description": "",
    "lineNumber": 269,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "sender",
        "description": "The function that send the offer to the remote\ninitiating peer."
      },
      {
        "nullable": null,
        "types": [
          "MRequest"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "The request message containing offers, peerId, etc."
      }
    ],
    "return": null
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "disconnect",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#disconnect",
    "access": "public",
    "description": "Remove an arc. If it was the last arc,\nthe WebRTC connexion is downgraded to the dying table. In this table, the\nconnexion will be closed if none create it.",
    "lineNumber": 407,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The identifier of the peer. If no arg,\nremove all arcs."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "send",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#send",
    "access": "public",
    "description": "Send a message to a remote peer.",
    "lineNumber": 468,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} Resolved when the message is sent, reject\notherwise. Note that loss of messages is not handled by default."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "peerId",
        "description": "The remote peer to send the message to."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message to send."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "retry",
        "description": "Retry few times to send the message before\ngiving up."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "Resolved when the message is sent, reject\notherwise. Note that loss of messages is not handled by default."
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "stream",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#stream",
    "access": "public",
    "description": null,
    "lineNumber": 500,
    "undocument": true,
    "params": [
      {
        "name": "peerId",
        "types": [
          "*"
        ]
      },
      {
        "name": "media",
        "types": [
          "*"
        ]
      },
      {
        "name": "retry",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "_sendRenegociateRequest",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_sendRenegociateRequest",
    "access": "private",
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "to",
        "types": [
          "*"
        ]
      },
      {
        "name": "retry",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_sendRenegociateResponse",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_sendRenegociateResponse",
    "access": "private",
    "description": null,
    "lineNumber": 572,
    "undocument": true,
    "params": [
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "to",
        "types": [
          "*"
        ]
      },
      {
        "name": "retry",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_receiveInternalMessage",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_receiveInternalMessage",
    "access": "private",
    "description": null,
    "lineNumber": 609,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "neighbours",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#neighbours",
    "access": "public",
    "description": "return an array of living sockets",
    "lineNumber": 618,
    "return": {
      "nullable": null,
      "types": [
        "[ELiving]"
      ],
      "spread": false,
      "description": "a living entry with socket, peer id and number of occurences (arcs)"
    },
    "params": []
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "_checkPendingEntry",
    "memberof": "lib/neighborhood.js~Neighborhood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/neighborhood.js~Neighborhood#_checkPendingEntry",
    "access": "private",
    "description": null,
    "lineNumber": 626,
    "undocument": true,
    "params": [
      {
        "name": "entry",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# neighborhood-wrtc [![Build Status](https://travis-ci.org/RAN3D/neighborhood-wrtc.svg?branch=master)](https://travis-ci.org/RAN3D/neighborhood-wrtc)\n\n<i>Keywords: WebRTC, browser-to-browser communication, overlay network</i>\n\nProject that aims to ease the WebRTC connection establishment process. Among\nothers, it alleviates the need to know which socket produced which offer.  It\nalso reuses existing connections instead of establishing new ones, when this is\npossible. It aims to be part of network protocols that build overlay networks\nand to provide them logical arcs - using identifiers - instead of channels.\nFinally, it is designed to handle multiple protocols, for they may share\nidentical arcs. For instance, consider several applications embedded in a single\nweb page, some of them are connected to a same peer. Instead of working\ncompletely on their own, these applications will share the same channel. The\nneighborhood-wrtc module will redirect the messages to the right applications.\n\nNote: The [API](https://ran3d.github.io/neighborhood-wrtc/) may change to face\nthe need of overlay network protocols.\n\nNeighborhood-wrtc is built on top of the (who said amazing?)\n[simple-peer](https://github.com/feross/simple-peer) project.\n\n\n## Principle\n\n<p align='center'>\n<img src='./img/notsharing.png'> </img>\n</p>\n\nThree peer-to-peer applications ```8O```, ```:|``` and ```>_<``` run in a same\ntab of a WebRTC-compatible browser. When they want to connect to their\nrespective remote counterpart, the browser must establish 3 WebRTC connections,\nfor they do not share any information between each other.\n\n<p align='center'>\n<img src='./img/sharing.png'> </img>\n</p>\n\nUsing this module to create WebRTC connections, they can share it and messages\nwill be automatically redirected to corresponding applications. In this example,\ninstead of establishing and maintaining 3 distinct connections -- which may be\ncostly in terms of time and bandwidth -- neighborhood-wrtc only establish 1. The\nconnection is destroyed only if the 3 applications remove it.\n\n## Installation\n\n```\n$ npm install neighborhood-wrtc\n```\n\n## API\n\nYou can find the API [here](https://ran3d.github.io/neighborhood-wrtc/).\n\nWant to create your protocol?\n```javascript\n// import the lib\nimport Neighborhood from 'neighborhood-wrtc'\n// create a class that fullfilled the [following API](https://ran3d.github.io/neighborhood-wrtc/class/lib/interfaces/iprotocol.js~IProtocol.html)\nclass P extends Neighborhood { // check IProtocol to see the interface\n  _connected (peerId) {\n    console.log('@%s: an arc has been created.', this.PEER)\n  };\n\n  _disconnected (peerId) {\n    console.log('@%s: an arc has been removed.', this.PEER, peerId)\n  };\n\n  _received (peerId, message) {\n    console.log('@%s: message received from @%s: %s',\n      this.PEER, peerId, message)\n  };\n\n  _failed (peerId) {\n    console.log('%s: failed to establish a connection with %s.',\n      this.PEER, peerId)\n  };\n};\n\n// create the Peer\nconst p1 = new Neighborhood({\n  peer: 'peer1',\n  config: {\n    config: {iceServers: [...]},\n    trickle: true\n  }\n})\n\n// create the Peer\nconst p2 = new Neighborhood({\n  peer: 'peer2',\n  config: {\n    config: {iceServers: [...]},\n    trickle: true\n  }\n})\n\n// now connec them\n// #3 callback functions ensuring the peers exchanges messages\n// from -> to -> from\nconst callback = (from, to) => {\n  return (offer) => {\n    to.connect((answer) => { from.connect(answer) }, offer)\n  }\n}\n\n// #4 establishing a connection from p1 to p2\np1.connect(callback(p1, p2))\n// now p1 can send message to p2 and p2 can send message to p1\n//\n// call any function of [the following API](https://ran3d.github.io/neighborhood-wrtc/class/lib/interfaces/ineighborhood.js~INeighborhood.html)\n\n```\n\n## Examples\n\nUsage examples of this module can be found\n[simple](https://ran3d.github.io/neighborhood-wrtc/examples/simple.html),\n[multiple](https://ran3d.github.io/neighborhood-wrtc/examples/multiple.html) and [media](https://ran3d.github.io/neighborhood-wrtc/examples/media.html).  To\nrun the example, make sure your web browser is\n[WebRTC-compatible](https://webrtc.org) and switch to console mode.\n\nModule [n2n-overlay-wrtc](https://github.com/ran3d/n2n-overlay-wrtc) uses this\nmodule to establish WebRTC connections from neighbor-to-neighbor, i.e., at most\n1 hop distance.\n\n## Socket\n\nBy default we used [simple-peer](https://github.com/feross/simple-peer) as Socket but if you want to change the type of Socket you want to use you'll need to follow this API:\n\n```\nnew Neighborhood({\n    socketClass: YourFavouriteSocketClass\n})\n```\n\n```js\n// ### events\n\n// emit when the connection is established\nsocket.on('connect', () => {})\n\n// emit when the socket is closed\nsocket.on('close', () => {})\n\n// emit when data is received\nsocket.on('data', (data) => {})\n\n// emit when a stream is received\nsocket.on('stream', (stream) => {})\n\n// emit when an error occured\nsocket.on('error', (error) => {})\n\n// emit when an offer is created\nsocket.on('signal', (offer) => {})\n\n//### functions\n\n// destroy the socket and emite the event close\n// `Destroy and cleanup this peer connection.`\nsocket.destroy()\n\n// pass an offer to the peer\nsocket.signal(offer)\n\n// send data to the socket\nsocket.send(data)\n```\n",
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n    \"name\": \"neighborhood-wrtc\",\n    \"version\": \"3.1.0\",\n    \"description\": \"neighborhood (or partial view) containing peers to communicate with\",\n    \"main\": \"lib/iprotocol.js\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/ran3d/neighborhood-wrtc\"\n    },\n    \"keywords\": [\n        \"WebRTC\",\n        \"browser-to-browser communication\",\n        \"overlay network\"\n    ],\n    \"author\": \"Chat-Wane\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"debug\": \"^3.1.0\",\n        \"lodash\": \"^4.17.10\",\n        \"simple-peer\": \"^9.x.x\",\n        \"uuid\": \"^3.2.1\"\n    },\n    \"bundledDependencies\": [\n        \"simple-peer\",\n        \"uuid\",\n        \"lodash\",\n        \"debug\"\n    ],\n    \"devDependencies\": {\n        \"babel-core\": \"^6.26.3\",\n        \"babel-preset-env\": \"^1.7.0\",\n        \"babelify\": \"^8.0.0\",\n        \"browserify\": \"^16.2.2\",\n        \"esdoc\": \"^1.1.0\",\n        \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n        \"esdoc-node\": \"^1.0.3\",\n        \"esdoc-standard-plugin\": \"^1.0.0\",\n        \"snazzy\": \"^7.1.1\",\n        \"standard\": \"^11.0.1\",\n        \"uglify-js\": \"^3.4.1\"\n    },\n    \"scripts\": {\n        \"lint\": \"standard \\\"./examples/**/*.js\\\" \\\"./lib/**/*.js\\\" --verbose | snazzy\",\n        \"fix\": \"standard --fix \\\"./examples/**/*.js\\\" \\\"./lib/**/*.js\\\" | snazzy \",\n        \"esdoc\": \"esdoc && npm run esdoc:example\",\n        \"esdoc:example\": \"cp -R ./build ./examples ./img ./docs\",\n        \"test\": \"npm run all\",\n        \"all\": \"npm run fix && npm run debug && npm run build && npm run min && npm run esdoc\",\n        \"debug\": \"browserify -r ./lib/neighborhood.js:neighborhood-wrtc -t [ babelify --presets [ env ] ] --debug > build/neighborhood-wrtc.bundle.debug.js\",\n        \"build\": \"browserify -r ./lib/neighborhood.js:neighborhood-wrtc -t [ babelify --presets [ env ] ] > build/neighborhood-wrtc.bundle.js\",\n        \"min\": \"browserify -r ./lib/neighborhood.js:neighborhood-wrtc -t [ babelify --presets [ env ] ] | uglifyjs > build/neighborhood-wrtc.bundle.min.js\",\n        \"all:build\": \"npm run build && npm run debug && npm run min\"\n    }\n}\n",
    "longname": "/home/travis/build/RAN3D/neighborhood-wrtc/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]